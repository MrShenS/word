`





# **光宗耀组知识总结**



[TOC]



## HTML5新特性

<https://www.cnblogs.com/vicky1018/p/7705223.html>

1. 语义标签

     ![](C:\Users\DELL\Desktop\语义标签.png)

2. 增强型表单

     ![](C:\Users\DELL\Desktop\增强型表单.png)

3. 视频和音频

4. Canvas绘图: 标签只是图形容器，必须使用脚本来绘制图形。

5. SVG绘图 :　SVG是指可伸缩的矢量图形

   **SVG 与 Canvas两者间的区别**

   > 　　SVG 是一种使用 XML 描述 2D 图形的语言。
   >
   > 　　Canvas 通过 JavaScript 来绘制 2D 图形。
   >
   > 　　SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。
   >
   > 　　在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
   >
   > 　　Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。

6. 地理定位:HTML5 Geolocation（地理定位）用于定位用户的位置。

   ```
   window.navigator.geolocation {
       getCurrentPosition:  fn  用于获取当前的位置数据
       watchPosition: fn  监视用户位置的改变
       clearWatch: fn  清除定位监视
   }
   ```

   

7. 拖放API

   拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。

   　　拖放的过程分为源对象和目标对象。源对象是指你即将拖动元素，而目标对象则是指拖动之后要放置的目标位置。

8. Web Worker

     当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。

        　　web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。

        　　首先检测浏览器是否支持 Web Worker

9. Web Storage

   使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是cookies。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能。数据以 键/值 对存在, web网页的数据只允许该网页访问使用。

   客户端存储数据的两个对象为：

   - localStorage - 没有时间限制的数据存储
   - sessionStorage - 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。

   　　在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage

   

   ## **CSS和CSS3区别**

   

   CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称。
   CSS 是一种标记语言，属于浏览器解释型语言，可以直接由浏览器执行，不需要编译。
   CSS 是用来表现HTML或XML的标记语言。
   CSS 是由W3C的CSS工作组发布推荐和维护的.
   CSS 是编程入门人员的必修课，运用CSS样式可以让页面变得美观。
   CSS语法由三部分构成：选择器、属性和值： selector {property: value}
   CSS3 是最新的 CSS 标准。
   css3比css多了一些样式设置而已。 css3是向前兼容的，也就是说，css中有效的code在css3也有效。 
   一个css与css3都有效的code，如果浏览器不支持css3，那么只会以css的样式显示。最常见的就是圆弧角。
   一个只在css3中有效的code，如果浏览器不支持css3，那么其显示效果就不会出现。 css3和css，在编写code的时候，除了对一些css3中新出现的属性设置，其它完全一样。
   CSS3新增属性
   box-shadow(阴影效果)
   border-colors(为边框设置多种颜色) 
   boder-image(图片边框)
   text-shadow(文本阴影)
   text-overflow(文本截断)
   border-radius(圆角边框)
   opacity(不透明度) 
   box-sizing(控制盒模型的组成模式):指定两个boxes接壤
   resize(元素缩放):指定一个div元素，允许用户调整大小
   outline(外边框)
   background-origin(指定背景图片从哪里开始显示)
   background-clip(指定背景图片从什么位置开始裁切) 
   background(为一个元素指定多个背景)

   


   　













## HTTP相关知识

   结构 ：
   请求首部：
		请求行：包含请求的方法，请求的URL和请求的HTTP版本
		请求首部字段：从客户端向服务器端发送请求报文是使用的首部。补充说  						明了请求的附加内容、客户端信息、响应内容优先级等						信息。
		通用首部字段：请求报文和响应报文都会用到的首部
		实体首部字段：针对请求报文和响应报文实体部分使用的字段。补充说明					     了资源内容、更新时间等与实体有关的信息。
		其他：如set-cookies等非Http协议的请求头
		空行：[CR+LF]由它来划分
		报文主体：应该被发送的数据（并不一定要有报文主体）

响应报文：
	报文首部：
	状态行：包含Http版本号，响应结果状态码和原因语句
	响应首部字段：从服务器向客户端返回响应报文是使用的首部。补充说明了响   					应的附加内容，也会要求客户端附加额外的 内容信息 。
	通用首部字段：同上
	实体首部字段：同上
	其他：同上
	空行：同上
	报文主体：同上

![](C:\Users\DELL\Desktop\http结构.png)

![](C:\Users\DELL\Desktop\Requesrt.png) 

 特点：  	 

1. 支持客户端/服务器模式
   
2. 简单快速 ： 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
   
3. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。
4. 无连接 所谓无连接是指默认http协议限制每一次连接只处理一个请求。服务器处理完客户端的请求，并受到客户端的应答后即断开连接。
5. 无状态 是指Http协议对事务处理没有记忆能力，服务器不知道客户端是什么状态，客户端的每一请求都是独立的，服务器根据请求，响应客户端的请求，但不会记录任何客户端信息

 优缺点：
       http的无连接，采取这种方式可以节约大量时间。但是随着互联网的发展,网页不在是简单的静态页面，需要处理大量的图片等，这样每一次访问都需要建立一次连接效率很低。Http 1.1Keep-Alive 被提出用来解决这效率低的问题。

HTTP的无状态这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的。两种用于保持 HTTP连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。







## flex布局

布局的传统解决方案是基于盒状模型，依赖 `display` + `position` + `float` 方式来实现，灵活性较差。2009年，W3C提出了一种新的方案-Flex，Flex是Flexible Box的缩写，意为”弹性布局”。Flex可以简便、完整、响应式地实现多种页面布局。

### 1 基本概念

采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。

Flex项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

Flex属性分为两部分，一部分作用于容器称容器属性，另一部分作用于项目称为项目属性。下面我们就分部的来介绍它们。

### 2 Flex容器属性

#### 2.1 flex容器定义

**基本语法：**

```
.box {
  display: flex; /* 或者 inline-flex */
}
```

上述写法，定义了一个flex容器，根据设值的不同可以是块状容器或内联容器。这使得直接子结点拥有了一个flex上下文。

#### 2.2 `flex-direction`

`flex-direction`属性决定主轴的方向（即项目的排列方向）。

**基本语法：**

```
.box {
    flex-direction: row | row-reverse | column | column-reverse;
}
```

- `row` 表示从左向右排列
- `row-reverse` 表示从右向左排列
- `column` 表示从上向下排列
- `column-reverse` 表示从下向上排列

#### 2.3 `flex-wrap`

缺省情况下，Flex项目都排在一条线（又称"轴线"）上。我们可以通过`flex-wrap`属性的设置，让Flex项目换行排列。

**基本语法：**

```
.box {
    flex-wrap: nowrap | wrap | wrap-reverse;
}
```

- `nowrap`(缺省)：所有Flex项目单行排列
- `wrap`：所有Flex项目多行排列，按从上到下的顺序
- `wrap-reverse`：所有Flex项目多行排列，按从下到上的顺序

#### 2.4 `flex-flow`

```
flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap
```

**基本语法：**

```
.box {
    flex-flow: <‘flex-direction’> || <‘flex-wrap’>
}
```

#### 2.5 `justify-content`

`justify-content`属性定义了项目在主轴上的对齐方式及额外空间的分配方式。

**基本语法：**

```
.box  {
    justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;
}
```

- `flex-start`(缺省)：从启点线开始顺序排列
- `flex-end`：相对终点线顺序排列
- `center`：居中排列
- `space-between`：项目均匀分布，第一项在启点线，最后一项在终点线
- `space-around`：项目均匀分布，每一个项目两侧有相同的留白空间，相邻项目之间的距离是两个项目之间留白的和
- `space-evenly`：项目均匀分布，所有项目之间及项目与边框之间距离相等

#### 2.6 `align-items`

`align-items`属性定义项目在交叉轴上的对齐方式。

**基本语法：**

```
.box {
  align-items: stretch | flex-start | flex-end | center | baseline;
}
```

- `stretch`(缺省)：交叉轴方向拉伸显示
- `flex-start`：项目按交叉轴起点线对齐
- `flex-end`：项目按交叉轴终点线对齐
- `center`：交叉轴方向项目中间对齐
- `baseline`：交叉轴方向按第一行文字基线对齐

#### 2.7 `align-content`

`align-content`属性定义了在交叉轴方向的对齐方式及额外空间分配，类似于主轴上`justify-content`的作用。

**基本语法：**

```
.box {
    align-content: stretch | flex-start | flex-end | center | space-between | space-around ;
}
```

- `stretch` (缺省)：拉伸显示
- `flex-start`：从启点线开始顺序排列
- `flex-end`：相对终点线顺序排列
- `center`：居中排列
- `space-between`：项目均匀分布，第一项在启点线，最后一项在终点线
- `space-around`：项目均匀分布，每一个项目两侧有相同的留白空间，相邻项目之间的距离是两个项目之间留白的和

## 目属性

### 3.1 `order`

缺省情况下，Flex项目是按照在代码中出现的先后顺序排列的。然而`order`属性可以控制项目在容器中的先后顺序。

**基本语法：**

```
.item {
  order: <integer>; /* 缺省 0 */
}
```

按`order`值从小到大顺序排列，可以为负值，缺省为0。

### 3.2 `flex-grow`

`flex-grow`属性定义项目的放大比例，`flex-grow` 值是一个单位的正整数，表示放大的比例。默认为0，即如果存在额外空间，也不放大，负值无效。

如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

**基本语法：**

```
.item {
  flex-grow: <number>; /* 缺省 0 */
}
```

### 3.3 `flex-shrink`

`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。0表示不缩小，负值无效。

**基本语法：**

```
.item {
  flex-shrink: <number>; /* 缺省 1 */
}
```

### 3.4 `flex-basis`

`flex-basis`属性定义项目在分配额外空间之前的缺省尺寸。属性值可以是长度（20%，10rem等）或者关键字`auto`。它的默认值为auto，即项目的本来大小。

**基本语法：**

```
.item {
  flex-basis: <length> | auto; /* 缺省 auto */
}
```

### 3.5 `flex`

`flex`属性是`flex-grow`, `flex-shrink` 和`flex-basis`的简写，默认值为0 1 auto。后两个是可选属性。

**基本语法：**

```
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```

一般推荐使用这种简写的方式，而不是分别定义每一个属性。

### 3.6 `align-self`

`align-self`属性定义项目的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

**基本语法：**

```
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

除了auto值以外，`align-self`属性与容器的`align-items`属性基本一致。

### 4 兼容性

| Chrome | Safari | Firefox | Opera | IE   | Android | iOS  |
| ------ | ------ | ------- | ----- | ---- | ------- | ---- |
| 21+    | 6.1+   | 22+     | 12.1+ | 11+  | 4.4+    | 7.1+ |

Flexbox需要一些特定的前缀以支持大多数的浏览器。甚至还存在完全不同的属性名称或属性值。这就需要[Autoprefixer](https://github.com/postcss/autoprefixer)或类似的CSS后处理器的辅助，具体内容请参考相关文档。

## 伪类

伪类对元素进行分类是基于特征(characteristics)而不是它们的名字、属性或者内容；原则上特征是不可以从文档树上推断得到的。

##### CSS术语

CSS伪类是用来添加一些选择器的特殊效果。

解释：在感觉上伪类可以是动态的，当用户和文档进行交互的时候一个元素可以获取或者失去一个伪类。例外的是":first-child"能通过文档树推断出来，":lang"在一些情况下也在从文档树中推断出来。

由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。 [1] 

伪类有：[:first-child](https://baike.baidu.com/item/%3Afirst-child/9102907) ，[:link](https://baike.baidu.com/item/%3Alink/8751680):，vistited，[:hover](https://baike.baidu.com/item/%3Ahover/8751300):，[:active](https://baike.baidu.com/item/%3Aactive/8952813)，[:focus](https://baike.baidu.com/item/%3Afocus/8954055)，:lang，:right，:left，:first

何为伪类?就是css内置类css内部本身赋予它一些特性和功能，也就是你不用再class=...或id=...你就可以直接拿来使用，当然你也可以改变它的部分属性

[CSS](https://baike.baidu.com/item/CSS/5457)很多的建议并没有得到浏览器的支持，但有四个可以安全用在[超链](https://baike.baidu.com/item/超链)接上的伪类。

##### 释义

伪类（Pseudo classes）是[选择符](https://baike.baidu.com/item/选择符)的螺栓，用来指定一个或者与其相关的选择符的状态。它们的形式是selector:pseudo class { property: value; }，简单地用一个[半角](https://baike.baidu.com/item/半角)英文[冒号](https://baike.baidu.com/item/冒号/998617)（:）来隔开选择符和伪类。

CSS很多的建议并没有得到浏览器的支持，但有四个可以安全用在超链接上的伪类。

:link用在未访问的连接上。

:visited用在已经访问过的连接上。

[:active](https://baike.baidu.com/item/%3Aactive/8952813)用于获得焦点（比如，被点击）的连接上。

[:hover](https://baike.baidu.com/item/%3Ahover/8751300) 用于鼠标光标置于其上的连接。

##### 示例

伪类中有代表性的两个是 ::after 和 ::before，举一个例子，比如想做一个如图1所示的分割线，代码如下：

```css
<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
        <style type="text/css">
            p{
                text-align:center;
            }
            p:after, p:before{
                content:"";
                position:absolute;
                height:2px;
                width:200px;
            }
            p:after{
                right:0;
                background-color:red;
            }
            p:before{
                left:0;
                background-color:green;
            }
        </style>
        <title>test</title>
    </head>
    <body>
        <p>
            测试
        </p>
    </body>
</html>
```

使用chrome浏览器查看源代码会发现有::before和::after提示

## 注意

尽管[CSS](https://baike.baidu.com/item/CSS/5457)给予你绕开的控制权，用不同的[颜色](https://baike.baidu.com/item/颜色/5014)表示已经访问过的[连接](https://baike.baidu.com/item/连接/70199)是一个很好的习惯，因为很多用户还是这样预期的。伪类（除了[hover](https://baike.baidu.com/item/hover)）不常用，恐怕也没有过去常用。因此，它没有过去那样有用了。但如果你能收集常用用户的意见，你会发现应该使用它。

传统上，连接文本是蓝色的，已访问的连接是紫色的。也许，这是最有效、最有用的颜色。然而，伴随着CSS的广泛发展，这种颜色不会是平常的了，用户也不再假设连接必须是[蓝色](https://baike.baidu.com/item/蓝色/35972)或紫色的。

注意

你应该也可以在除了连接的其他元素上使用hover伪类。

# LESS 和 SASS

#### 一. Sass/Scss、Less是什么?

#### Sass (Syntactically Awesome Stylesheets)是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。

**Sass与Scss是什么关系?**

#### Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。

#### Less也是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量，继承，运算， 函数.  Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。

#### 二. Sass/Scss与Less区别

###### 1.编译环境不一样

Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。

###### 2.变量符不一样，Less是@，而Scss是$，而且变量的作用域也不一样。

```css
Less-作用域
@color: #00c; /* 蓝色 */
#header {
  @color: #c00; /* red */
  border: 1px solid @color; /* 红色边框 */
}

#footer {
  border: 1px solid @color; /* 蓝色边框 */
}

Less-作用域编译后
#header{border:1px solid #cc0000;}
#footer{border:1px solid #0000cc;}

scss-作用域
$color: #00c; /* 蓝色 */

#header {

  $color: #c00; /* red */
  border: 1px solid $color; /* 红色边框 */
}

#footer {
  border: 1px solid $color; /* 蓝色边框 */
}

Sass-作用域编译后

#header{border:1px solid #c00}
#footer{border:1px solid #c00}

我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。
```

##### 3.输出设置，Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。

输出样式的风格可以有四种选择，默认为nested

- nested：嵌套缩进的css代码
- expanded：展开的多行css代码
- compact：简洁格式的css代码
- compressed：压缩后的css代码

##### 4.Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。

```scss
/* Sample Sass “if” statement */

@if lightness($color) > 30% {

} @else {

}

/* Sample Sass “for” loop */

@for $i from 1 to 10 {
  .border-#{$i} {
    border: #{$i}px solid blue;
  }
}
```

#####  5. 引用外部CSS文件

scss引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss、_test2.scss、_test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线_开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件.

```css
// 源代码：
@import "_test1.scss";
@import "_test2.scss";
@import "_test3.scss";
// 编译后：
h1 {
  font-size: 17px;
}
 
h2 {
  font-size: 17px;
}
 
h3 {
  font-size: 17px;
}
 
```

Less引用外部文件和css中的@import没什么差异。

##### 6.Sass和Less的工具库不同

Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。

Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。

#### 三. 总结

不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。

## JS闭包和原型链

【作用域】
javascript中的作用域可以理解为一个语句执行的环境大小，有全局的作用域，函数作用域和eval作用域。在JS中没有块级作用域。
讲到作用域，不得不讲执行环境，执行环境在JS中是最为重要的概念。执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。在web浏览器中全局环境被认为是window对象，某个执行环境中的所有代码执行完毕后就被该环境销毁，保存在其中的所有变量和函数定义也随即销毁。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在环境的变量对象。作用域链中的下一个变量对象来自包含（外部）环境，在下一个变量对象则来自于在下一个包含环境，这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。

需注意的是：在局部作用域中定义的变量可以在全局环境和局部环境中交互使用。内部环境可以通过作用域链访问所有的外部环境，但外部环境不可以访问内部环境中的任何变量和函数。每个环境都可以向上搜索作用域链，以查询变量和函数名，但任何环境都不可以通过向下搜索作用域链而进入另一个执行环境。

作用域链本质上是一个指向变量对象的指针列表，他只引用但不包含变量对象。

【闭包】
闭包是指有权访问另一个函数作用域中的变量的函数，这里要把它与匿名函数区分开（匿名函数：创建一个函数并将它赋值给一个变量，这种情况下创建的函数叫匿名函数，匿名函数的name属性是空字符串），创建闭包的常见方式就是在一个函数内部创建另一个函数。闭包保存的是整个变量的对象。

闭包的作用：在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量，这时灵活方便的闭包就派上用场，我们知道当一个函数被调用时就会创建一个执行环境及相应的作用域链，那么闭包就会沿着作用域链获取到开发者想要的变量及元素。

注：在维基百科中是这样定义闭包的：闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起。这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。——闭包不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。

闭包灵活方便，也可以实现封装，这样就只能通过对象的特定方法才能访问到其属性。但是，不合理的使用闭包会造成空间的浪费，内存的泄露和性能消耗。

【原型和原型链】
讲到原型链，不得不讲讲用于创建对象的原型模式：我们创建每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定的所有实例共享的属性和方法。从字面意思理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个与原型实例中同名的属性，那么我们在实例中创建该属性，该属性将会屏蔽原型中的属性。

无论什么时候，只要创建一个新函数，就会根据一组特定的规则为函数创建一个prototype（原型）属性，这个属性指向函数的原型对象。

原型链：用于实现JS中的实现继承。（许多语言都支持两种方式的继承：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScriot中只能实现实现继承。

原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用继承的属性和方法。了解一下构造函数、原型和实例的关系：每个构造函数都是一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。假如我们让原型对象等于另一个类型的实例，那么此时的原型对象将包含一个指向另一个原型的指针，相应的另一个原型中包含着一个指向另一个构造函数的指针。如此层层递进，就构成了实例与原型的链条。这就是原型链的概念。

当函数调用时，需查找和获取的变量和元素都会通过原型链机制一层层的往上搜索在原型对象或继承来的对象中获得。

当函数被创建，就有了作用域，当被调用时，就有了作用域链，当被继承时就有了原型链，当需要获取作用域链或原型链上的变量或值时，就有了闭包。

## ES6 和 TS

ES6是什么

ECMAScript 6.0（以下简称ES6）是JavaScript语言（现在是遵循ES5标准）的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。

ECMAScript和JavaScript的关系

由于JavaScript的创造者Netscae公司的版权问题，ECMAScript不能叫Javascript。总之，ECMAScript和JavaScript的关系是，前者是后者的规格（语言规范），后者是前者的一种实现。

JavaScript 与 TypeScript 的关系

TypeScript是Javascript的超集，实现以面向对象编程的方式使用Javascript。当然最后代码还是编译为Javascript。

TypeScript和ES6的关系

TypeScript是ES6的超集。至于需不需要使用，在于你所需要的场景。比如在Angular2中，用TypeScript明显好于ES6。



## Storage和Cookie

cookie：存储数据，当用户访问了某个网站（网页）的时候，我们就可以通过cookie向来访问者电脑存储数据

不同的浏览器存放的cookie位置不一样，也是不能通用的
cookie的存储是以域名的形式进行区分的
cookie的数据可以设置名字
一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样
每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样
我们通过documen.cookie来获取当前网站下的cookie的时候，得到的是字符串形式的值，它包含了当前网站下所有的cookie，它会把所有的cookie通过一个分号+空格的形式串联起来

如果我们想要长时间存放一个cookie。需要在设置这个cookie的时候同时给它设置一个过期的时间

cookie默认是临时存储的，当浏览器关闭进程的时候自动销毁

Cookie的特点：
存储限制：    —域名100个cookie，每组值大小4KB
客户端、服务器端，都会请求服务器（头信息）
页面间的cookie是共享的（同一个浏览器下的）
下面是cookie的存取和删除的封装函数

```javascript
//获取cookie
function getCookie(key){
    var arr = document.cookie.split("; ");
    for(var i=0; i<arr.length;i++){
        var arr2 = arr[i].split("=");
        if(arr2[0]==key){
            return decodeURI(arr2[1])
        }
    }
}
//设置cookie
    function setCookie(key,value,t){
        var oDate = new Date();
        oDate.setDate(oDate.getDate()+t);
        document.cookie = key + '='+value+';expries ='+oDate.toGMTString();
    }
    //删除cookie
function removeCookie(key){
    setCookie(key,-1)
}
```

storage
  .sessionStorage
  —session临时会话，从页面打开到页面关闭的时间段
 —窗口的临时存储，页面关闭，本地存储消失
.localStorage
 —永久存储（可以手动删除数据）

storage的特点
存储量限制（5M）
客户端完成，不会请求服务器处理
sessionStorage数据是不共享、localSorage共享
Storage API
.setItem():
  设置数据，key/value类型，类型都是字符串
  可以用获取属性的形式操作
.getItem():
  获取数据，通过Key来删除相应的value
.removeItem():
删除数据，通过key来删除相应的value
.clear():
删除全部存储的值
存储事件：
当数据有修改或删除的情况下，就会触发storage事件
在对数据进行改变的窗口对象上是不会触发的
key：修改或删除的key值，如果调用clear()，key为null
newValue：新设置的值，如果调用removeStorage()，key为null
oldValue：调用改变前的value值
storageArea:当前的storage对象
url：触发该脚本变化的文档的url
注：session同窗口才可以：例如iframe操  作

看一个小例子：

<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>无标题文档</title>
<script>

​	
​	<!DOCTYPE html>
​	<html lang="en">
​	<head>
​	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
​	<title>无标题文档</title>
​	<script>
​	
```html
window.onload = function(){
	var aInput = document.getElementsByTagName('input');
for(var i=0;i<aInput.length;i++){
	
	aInput[i].onclick = function(){
		
		if(this.checked){
			window.localStorage.setItem('sel',this.value);
		}
		else{
			window.localStorage.setItem('onSel',this.value);
		}
		
	};
	
}

window.addEventListener('storage',function(ev){  //当前页面的事件不会触发
	
	if( ev.key == 'sel' ){
		
		for(var i=0;i<aInput.length;i++){
			if( ev.newValue == aInput[i].value ){
				aInput[i].checked = true;
			}
		}
		
	}
	else if( ev.key == 'onSel' ){
		
		for(var i=0;i<aInput.length;i++){
			if( ev.newValue == aInput[i].value ){
				aInput[i].checked = false;
			}
		}
		
	}
	
},false);
};

</script>
</head>

<body>
<input type="checkbox" value="香蕉" />香蕉<br />
<input type="checkbox" value="苹果" />苹果<br />
<input type="checkbox" value="西瓜" />西瓜<br />
<input type="checkbox" value="哈密瓜" />哈密瓜<br />
</body>
</html>
```
