select table_name from user_tables

create table bank2 ( id number ,name varchar2(20),manoy number(5,2))

insert into bank values (2,'小蓝' ,500)

select * from bank

commit

select *from employees
1.
select last_name || first_name from employees
2.
 select * from employees where employee_id in (select manager_id from employees)
3.
select  e2.last_name || e2.first_name 员工,e1.last_name || e1.first_name 头  from employees e1,employees e2
 where e1.employee_id = e2.manager_id
4.
select  e2.last_name || e2.first_name 员工,e1.last_name || e1.first_name 头  from employees e1,employees e2
 where e1.employee_id = e2.manager_id and e2.salary>5000
5. 
 select * from employees where department_id in (select department_id from employees where salary between 3000 and 5000)
 
 6.
 select last_name || first_name 姓名 ,job_id ,salary from employees where salary>(select salary from employees where first_name='Bruce')
 
 7.
 select e.last_name||e.first_name,e.phone_number,e.salary,NVL(d.department_name,'NULL'),NVL(j.job_title,'NULL')  
from employees e,departments d,jobs j
where e.job_id=j.job_id
and e.department_id=d.department_id(+);
 
 8.
select * from employees where salary = (select  max(salary) from employees)  
 


9.
select * from departments where department_id =(
  select department_id from  (select count(*) cc ,department_id from employees group by department_id)    
    where cc = (select  max(cc)  from (select count(*) cc ,department_id from employees group by department_id))) 
    
10 

  select e.first_name , t.sa
       from  (select avg(salary) sa,department_id from employees group by department_id) t,employees e where e.salary>t.sa
                                                                                                     and t.department_id = e.department_id
																									 
	



        创建表	
																									 
																									 
																									 
																									 
create table student(
  SNO varchar2(10) primary key,
  SNAME varchar2(20),
  SAGE number(2),
  SSEX varchar2(5)
)

create table teacher (
    TNO varchar2(10) primary key,
    TNAME varchar2(20)
)
 
create table course(
    CNO varchar2(10) primary key,
    CNAME Varchar2(20),
    TNO varchar2(20) not null references teacher(TNO) 
)  



create table sc(
    CNO varchar2(20) not null references course(CNO),
    SNO varchar2(20) not null references student(SNO),
    Score number(4,2)
)



向表中插入数据
 insert into student values('1','申震',78,'男')
 insert into student values('2','张牛牛',59,'男')
 insert into student values('3','赵旭东',49,'男')
 
 
  insert into teacher values('T1','王中华')
  insert into teacher values('T2','郭怀明')  
  insert into teacher values('T3','一休哥')
select table_name  from user_tables 


insert into student values ('s001','学生一',23,'男');
insert into student values ('s002','学生二 ',23,'男');
insert into student values ('s003','学生三',25,'男');
insert into student values ('s004','学生四',20,'女');
insert into student values ('s005','学生五',20,'女');

insert into student values ('s006','学生六',21,'男');
insert into student values ('s007','学生七',21,'男');
insert into student values ('s008','学生八',21,'女');
insert into student values ('s009','学生九',23,'女');
insert into student values ('s010','学生十',22,'女');
commit;





insert into teacher values ('t001', '老师一');
insert into teacher values ('t002', '老师二');
insert into teacher values ('t003', '老师三');
commit;

insert into course values ('c001','J2SE','t002');
insert into course values ('c002','Java Web','t002');
insert into course values ('c003','SSH','t001');
insert into course values ('c004','Oracle','t001');
insert into course values ('c005','SQL SERVER 2005','t003');
insert into course values ('c006','C#','t003');
insert into course values ('c007','JavaScript','t002');
insert into course values ('c008','DIV+CSS','t001');
insert into course values ('c009','PHP','t003');
insert into course values ('c010','EJB3.0','t002');
commit;


insert into sc values ('s001','c001',78.9);
insert into sc values ('s002','c001',80.9);
insert into sc values ('s003','c001',81.9);
insert into sc values ('s004','c001',60.9);
insert into sc values ('s001','c002',82.9);
insert into sc values ('s002','c002',72.9);
insert into sc values ('s003','c002',81.9);
insert into sc values ('s001','c003','59');
commit;


学生系列表的练习

1.
select sc1.sno from sc sc1,sc sc2 where sc1.sno=sc2.sno and sc1.cno='c001' and sc2.cno='c002' and sc1.score<sc2.score
2.
select * from sc where SNO='s001' 

3. select sc.SNO ,s1.avgs from sc ,(select avg(score) avgs,SNO from sc group by SNO) s1 where s1.avgs>60 and s1.SNO =sc.SNO 


4. 
select count(*) ,sum(score),SNO from sc group by SNO
select distinct s.SNO,s.Sname,t1.c,t1.s from sc ,student s ,(select count(*) c,sum(score)s ,SNO from sc group by SNO) t1 where s.sno=t1.sno and sc.SNO=t1.SNO

5.
    select * from course
    select * from sc
    select CNO from course where TNO='t003' 
    select distinct SNO from sc where CNO not in (select CNO from course where TNO='t003')
    
6.    select distinct SNO from sc where CNO  in (select CNO from course where TNO='t003')
    
7.    
     select sc1.sno from sc sc1,sc sc2 where sc1.sno=sc2.sno and sc1.cno='c001' and sc2.cno='c002' and sc1.score>sc2.score

9.  
        select * from sc
      select count(*) from course; 
      select SNO from sc group by SNO having count(*)<(select count(*) from course) 
      select * from student where SNO in ( select SNO from sc group by SNO having count(*)<(select count(*) from course) )



10.   
     select * from student where sno in( select  sno from sc where CNO in( select CNO from sc where SNO ='s001'))
	 
11   
     同上
	 
12.     如何修改多条数据
     	  
         select TNO from teacher where TName='老师三'
         
         select CNO from course where TNO= (select TNO from teacher where TName='老师三')
         
         select avg(score) ,CNO from sc group by CNO 
         
         update sc set  CNO in (select CNO from course where TNO= (select TNO from teacher where TName='老师三'))
		 
		 
13 。
     delete from sc where CNO in ( select CNO from course where TNO= (select TNO from teacher where TName='老师三'))

	 


14.

15.
          select CNO ,max(score),min(score)  from sc group by CNO 
		  
		  
16.      
         （参加人数）  select count(*) ,CNO from sc group by CNO
     (及格人数)  select count(*) ,CNO from (select * from sc where score>60) s group by CNO
	 
     计算及格率：  select t2.c2/t1.c1 from (select count(*) c1 ,CNO from sc group by CNO) t1,
                      (select count(*) c2 ,CNO from (select * from sc where score>60) s group by CNO) t2 where t1.CNO=t2.CNO 
            
       select CNO from sc group by CNO order by avg(score) desc 
	   
17.	   
	      select c.TNO,c.cno, AVGS from course c,(select avg(score) avgs ,CNO from sc group by CNO) t where c.CNO=t.CNO order by TNO ,avgs
	  
	   
18.        
              
19.

20.  查询每门课程被选修的学生数
         select CNO ,count(*) 选修人数  from sc group by CNO

21.查询出只选修了一门课程的全部学生的学号和姓名
    select * from Student s,(select SNO ,Count(*) count from sc group by SNO) t where s.sno=t.sno and t.count=1

22.查询同名同性学生名单，并统计同名人数
      select s1.sname,count(*) 同名人数 from student s1,student s2 where s1.sno=s2.sno and s1.sname=s2.sname group by s1.sname

23.查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列
      select AVG(score)  from sc  group by CNO order by avg(score),CNO desc


      
--                                           练习
   select * from employees
   select * from departments
   select * from regions
   --  1.显示1997年以后受雇的职员的所有资料。
          select * from employees where hire_date >  to_date('01-01-1997', 'DD-MM-YYYY')
  --2.显示赚取佣金的雇员的姓氏、工作、薪金和佣金。按工资降序排列数据。
          select last_name,job_id, commission_PCT，  salary from employees order by salary desc 
          
  --3.给没有佣金的员工加薪10%(四舍五入)工资)。
      select   salary,  ceil(salary+(salary*0.1)) from employees where commission_PCT is null; 
  --4.显示所有员工的姓，以及他们的年岁和年号 以及他们受雇的几个月。
      select last_name,
  --5.显示那些名称以J、K、L或M开头的员工。
     select * from employees where last_name like 'J%' or  last_name like 'R%' or  last_name like 'L%' or  last_name like 'M%'
  --6.显示所有员工，并用“是”或“否”表示他们是否收到了佣金。
      
  --7.显示部门名称、地点、名称、职务名称和工作人员的工资在1800年的位置。
      select d.department_name,d.location_id,e.last_name,e.job_id,e.salary
           from employees e,departments d where e.department_id=d.department_id and d.location_id=1800
  --8有多少员工的名字以n结尾?创建两个可能的解决方案。 ?????????????
       --1).
           select count(*) from employees where first_name like '%n'
		   
		   
		   
		   
		   
		   
   



















作业：
--                                           练习
   select * from employees
   select * from departments
   select * from regions
   --  1.显示1997年以后受雇的职员的所有资料。
          select * from employees where hire_date >  to_date('01-01-1997', 'DD-MM-YYYY')
  --2.显示赚取佣金的雇员的姓氏、工作、薪金和佣金。按工资降序排列数据。
          select last_name,job_id, commission_PCT，  salary from employees order by salary desc 
          
  --3.给没有佣金的员工加薪10%(四舍五入)工资)。
      select   salary,  ceil(salary+(salary*0.1)) from employees where commission_PCT is null; 
  --4.显示所有员工的姓，以及他们的年岁和年号 以及他们受雇的几个月。
      select last_name,
  --5.显示那些名称以J、K、L或M开头的员工。
     select * from employees where last_name like 'J%' or  last_name like 'R%' or  last_name like 'L%' or  last_name like 'M%'
  --6.显示所有员工，并用“是”或“否”表示他们是否收到了佣金。
      select last_name,salary, nvl2(commission_PCT,'YES','NO') from employees
   
  
  --7.显示部门名称、地点、名称、职务名称和工作人员的工资在1800年的位置。
      select d.department_name,d.location_id,e.last_name,e.job_id,e.salary
           from employees e,departments d where e.department_id=d.department_id and d.location_id=1800
  --8有多少员工的名字以n结尾?创建两个可能的解决方案。 ?????????????
       --1).
           select  count(*)from employees where last_name like '%n'
           
       --2)
           select count(*) from employees where SUBSTR(last_name,length(last_name)-1,1) like '%n'
  --9 显示所有部门的名称和位置，以及每个部门的员工人数。确保没有员工的部门也包括在内。
       
    with t1 as( select department_id, count(*) c from employees group by department_id)
  
        select DISTINCT d.department_id,d.department_name,d.location_id,t1.c from departments d,t1
             where d.department_id=t1. department_id(+)
  
    
    
  --10  显示 10 和 20 部门有哪些职位?
      select job_id from employees where department_id = 10 or department_id =20
  --11. 行政和执行部门有哪些职位 ? 有多少 员工做这些工作?首先显示频率最高的工作 
          with d1 as (  select department_id did from departments where department_name in ('Administration','Executive')),
           t1 as( select e.job_id jid from employees e,d1 where e.department_id in (d1.did) )
           
           select jid ,count(*) from t1 group by  jid order by count(*) desc 
       
  --12.   显示本月上半月(本月16日前)招聘的所有员工。 
          select last_name,hire_Date from employees where TO_CHAR(hire_Date,'mm') = TO_CHAR(sysdate,'mm') and TO_CHAR(hire_Date,'dd')<16    
      select * from employees   
  
  --13.  显示所有员工的姓名、工资和收入(以千为单位)。
      select last_name || " " || first_name ,salary , 
      
  --14  显示所有管理人员工资高于15,000美元的员工。显示了 以下数据:员工姓名、经理姓名、经理工资、经理工资等级。
       select Table_name from user_tables 
       select * from COUNTRIES
       select * from Locations   
       select * from JOB_GRADES   --  员工等级 
  --15 显示部门编号、名称、员工人数、各部门平均工资，以及各部门员工的姓名、工资、职务
     with t as( select department_id dt ,avg(salary) a,count(*) c from employees group  by department_id) --显示各部们平均工资
       select d.department_id ,d.department_name ,t.c 员工人数,t.a 平均工资,e.last_name ,e.salary,e.job_id 
        from  t,employees e,departments d 
       where t.dt=d.department_id and e.department_id = d.department_id(+)
       
       显示没有销售代表工作的部门的编号、名称和位置 
  --16 显示平均工资最高的部门的部门号和最低工资 。   问题？？？？？？？？？？？？？？？？
       with avgSalary as (select avg(salary) av,department_id did from employees group by   department_id) 
           -- maxSalary as (select avg(salary) av,department_id did from employees group by   department_id)
       select av.did,min(e.salary) from avgSalary av,employees e where AV.did=e.department_id group by av.did
       
  --17 显示没有销售代表工作的部门的编号、名称和位置
        select JOB_ID from JOBS  where  job_TITLE = 'Sales Representative' 
        with t1 as (select  department_id did from employees where job_ID <>(select JOB_ID from JOBS  where  job_TITLE = 'Sales Representative'))
        
        select DISTINCT d.department_id,d.department_name,e.manager_id,d.location_id 
                  from departments d,t1,employees e 
                  where e.department_id=d.department_id and d.department_ID = t1.did
      
  --18  显示部门编号、部门名称，以及在每个部门工作的员工人数:
        --1)  员工人数少于3人
             with coun as (select department_id  ,count(*) con from employees group by department_id having count(*)<3)
            select d.department_id,d.department_name,c.con from coun c ,departments d where d.department_id=c.department_id   
       --2)  员工人数最多:
           with zui as( select count(*) c,department_id did from employees group by department_id order by count(*)desc), 
                  d as (select did ,zui.c coun from zui where rownum =1)
                 select d2.department_id,d2.department_name,d.coun from d,departments d2 where d2.department_id=d.did
          
       --3)  员工数最少 :
            with zui as( select count(*) c,department_id did from employees where to_number(department_id) <>0 group by department_id order by count(*)), 
                  d as ( select did ,zui.c coun from zui where rownum =1)
                 select d2.department_id,d2.department_name,d.coun from d,departments d2 where d2.department_id=d.did
  --19       显示所有员工的员工编号、姓氏、工资、部门编号和所在部门的平均工资。 
           with avgS as( select  department_id did,avg(salary) av from employees   group by department_id)
              select e.employee_id,e.last_name,e.salary,e.department_id,avgs.av from employees e ,avgs where avgs.did = e.department_id
              
                           
 --20    显示所有在一周中员工人数最多的那一天被雇佣的员工。
      with t1 as ( select * from(select count(*) , to_char(hire_date,'DY') dy 
                       from employees group by to_char(hire_date,'DY') order by count(*)desc)where rownum=1)
                       
       select last_name ,t1.dy from employees e,t1 where to_CHAR(e.hire_date,'DY')=  t1.dy                
             
       
             
 
 --21   根据员工的雇佣日期创建周年纪念概述。按升序排列周年纪念。   月份转换有问题
        
         select  last_name, TO_CHAR(hire_date, ' Month fmDD ')  birthday from employees order by hire_date         
              
    -- 22 找一份1990年上半年的工作和 1991年同期的工作。
       
    select JOB_ID from employees where to_char(hire_date,'YYYY')=1990 and to_char(hire_date,'MM')<7
    INTERSECT
    select JOB_ID from employees where to_char(hire_date,'YYYY')=1991 and to_char(hire_date,'MM')<7
 
    
    
   --23 编写一个复合查询，生成一个显示加薪百分比、员工id、旧工资和新工资增长的员工列表。
   --   部门 10 、 50 、110 的员工加薪5%，部门 60 
   --      的员工加薪10%，部门20、80的员工加薪15%，部门90的员工不加薪。
     select '5%'||'raise',employee_id,salary, 0.05*salary from employees where department_id in (10,50,110)
     UNION
     select '10%'||'raise',employee_id,salary, 0.1*salary from employees where department_id = 60
     UNION
     select'15%'||'raise',employee_id,salary, 0.15*salary from employees where department_id in (20,80)
     UNION
      select 'raise',employee_id,salary, salary from employees where department_id =90
 
 
 --24     修改会话，将NLS_DATE_FORMAT设置为DD-MON-YYYY HH24:MI:SS。
         alter session set    NLS_DATE_FORMAT = 'DD-MON-YYYY HH24:MI:SS'
      
 --25  
 
 --26 编写一个查询来显示姓氏、加入日期的月份和 雇佣日期  1月份入职的员工，不论入职年份    未找到加入时间字段
            
            select last_name,TO_CHAR(hire_date,'DD-MON-YYYY') from employees where to_CHAR(hire_date,'mm')=1
            
  --27     编写一个查询，为部门  ID 较大的部门显示以下内容 
          --     比80:
          --城市  部门名称   job――ID   部门工资和 
          
          
  --28 。写一个查询来显示以下分组:  部门ID，工作ID  工作ID，经理ID  查询应该计算每个组的最高和最低工资。
  
  
  --29 编写一个查询来显示EMPLOYEES表中收入最高的三个人。显示他们的姓和薪水。
       
       select * from (select Last_name ,salary from employees order by salary desc) where rownum<4   
               
   --30   编写一个查询来显示在加利福尼亚州工作的员工的ID和姓氏。     California.
   
      select e.employee_id,e.last_name   from employees e,departments d,locations l 
                    where e.department_id=d.department_id and d.location_id=l.location_id and l.state_province = 'California'
    -- 31. 编写一个查询，通过查找JOB_HISTORY表中雇员的最小值(START_DATE)来删除雇员最老的JOB_HISTORY行。只删除那些至少换过两份工作的员工的记录。
    --如果您的查询正确执行，您将得到反馈:
   --提示:使用相关的删除命令。
    
    
           
   --32 回滚事务
        ROLLBACK [WORK] [TO [SAVEPOINT] savepoint_name | FORCE 'string'}           
                    
    -- 33.编写一个查询，显示最高工资超过整个公司最高工资一半的工作的工作id。使用WITH子句编写这个查询。将查询命名为MAX_SAL_CALC。
           
                 with s1 as(select max(salary)m from employees)             
              ,s2 as (select max(salary) m,JOB_ID from employees   group by JOB_ID),
               select jobs.job_title,s2.m from s1,s2,jobs where s2.JOB_ID=jobs.Job_Id and s2.m> (s1.m)/2 
    --34  编写SQL语句，显示员工编号、姓氏、入职日期和工资，显示: 
     -- a)  De Haan的直接报道
     select employee_id,last_name,hire_date,salary from employees where manager_id = (
           select  employee_ID from employees where last_name = 'De Haan') 
     -- b)  De Haan下的组织树(员工编号102)
	 
     
     --35   编写一个分层查询，显示低于employee De Haan (employee number 102)两层的所有员工的员工编号、经理编号和员工姓。还显示员工的级别。
     
	 
     
     --36     生成分层报告，显示员工编号、经理编号、级别伪列和员工姓。对于EMPLOYEES表中的每一行，都应该打印一个树结构，
         --   显示employee、employee的manager、manager的manager等等。对NAME列使用缩进。
         
         
         
         
         
      --37 。写一个查询做以下事情:   从employees表中检索雇员ID大于或等于200的雇员的雇员ID、雇佣日期、工资和经理ID的详细信息。
         --  如果工资低于$5,000，则将员工ID和工资的详细信息插入SPECIAL_SAL表。
        --   将员工ID、雇佣日期和工资的详细信息插入SAL_HISTORY表。
          --将员工ID、经理ID和工资的详细信息插入到MGR_HISTORY表中。
          
          
          
          
      --38查询SPECIAL_SAL、SAL_HISTORY和MGR_HISTORY表，以查看插入的记录。
      
      
      
      
      
      
      --39根据下面的表实例图创建LOCATIONS_NAMED_INDEX。将主键列的索引命名为LOCATIONS_PK_IDX。
      
      
      
      
      --40  查询USER_INDEXES表，以显示LOCATIONS_NAMED_INDEX表的INDEX_NAME。
         










-----------------------------------------------------------------------PLSQL-----------------------------------------------------------------






--  1   ，    
 a选项  每行只能声明一个变量
 
 
 
 --2 在下面的每个赋值中，确定结果表达式的数据类型。 
 
/*
   a.  v_email := v_firstname || to_char(v_empno);     Atlanta(字符串类型)    
  b.  v_confirm := to_date('20-JAN-1999', 'DD-MON-YYYY');    日期类型
  c.  v_sal := (1000*12) +  500            数值类型
  d.	v_test := FALSE;    布尔类型
	e.	v_temp := v_temp1 < (v_temp2/ 3);   布尔类型	
	f.	v_var := sysdate;     日期类型
*/ 



-- 3，评估上述PL/SQL块，并根据作用域规则确定以下每个变量的数据类型和值:
/* 
	a. 	The value of V_CUSTID at position 1 is:	        300      
	b. 	The value of V_CUSTNAME at position 1 is:	     Shape up Sports Club' 'Jansports Club
	c. 	The value of V_NEW_CUSTID at position 2 is:    
 	d. 	The value of V_NEW_CUSTNAME at position 1 is:	300
	e. 	The value of V_CUSTID at position 2 is:		 1920
	f. 	The value of V_CUSTNAME at position 2 is:  'Women Sports Club
*/


/*
4.
   编写一个PL/SQL块来接受一个年份，并检查它是否是闰年。例如，如果输入的年份是1990年，那么输出应该是“1990年不是闰年”。
提示:年份应该能被4整除但不能被100整除，或者它应该能被整除
到400年。

*/ 

       --1)
        
          select case
             when (mod(&year, 4) = 0 and mod(&year, 100) != 0) or
                  (mod(&year, 400) = 0) then
              &year || '是闰年'
             else
              &year || '年不是闰年'
           end RESULT
            from dual;
        
         --2）
         
         
         DECLARE
                year  number(4) := &v_year;
            BEGIN
                IF ( (mod(year, 4) = 0 and mod(year, 100) != 0) or   (mod(year, 400) = 0) ) THEN
                    dbms_output.put_line(year || '年是闰年' );
               
                ELSE
                    dbms_output.put_line(year || '年不是闰年');
                END IF;
                dbms_output.put_line('Exact value of a is: '|| year );
            END;

/*
   5.   
      
        b.编写一个PL/SQL块，其中包含两个变量MESSAGE和DATE_WRITTEN。 将MESSAGE声明为VARCHAR2数据类型，长度为35,date_write为日期数据类型。
        为变量赋值如下:
         变量内容
               信息“这是我的第一个PL/SQL程序”
               date_written当前日期
        将值存储在TEMP表的适当列中。通过查询
        临时表。
        */
        
        DECLARE 
        MASSAGE varchar2(35):= 'This is my first PL/SQL program';
        date_write date :=sysdate;
        BEGIN
          insert into TEMP (CHAR_STORE,DATE_STORE) values (MASSAGE,DATE_WRITE);
        END;
        
          select * from TEMP
        
select table_name  from user_tables
--6.
  /*
       在iSQL* +替换变量中存储部门编号
       b.编写一个PL/SQL块来打印在该部门工作的人数。
       提示:在iSQL*Plus中启用DBMS_OUTPUT，并将SERVEROUTPUT设置为ON。
  */
     
 


/*
      编写一个PL/SQL块来声明一个名为v_salary的变量来存储员工的工资。在程序的可执行部分，执行以下步骤:
      将员工名存储在iSQL*Plus替换变量中
      将他或她的工资存储在变量v_salary中
      如果工资低于3000，则给员工加薪500，并在窗口中显示“< employee Name> ' s salary updated'”信息。
      如果工资超过3000，以“< employee Name> earn…”格式打印员工工资。
      测试PL/SQL以获得以下姓氏:注意:取消在脚本末尾存储员工姓名的变量的定义
*/
     declare 
       v_salary  employees.salary%type;
       cursor temp_salary_cursor is select salary from employees;
       BEGIN
        --打开游标
       open temp_salary_cursor;
       --提取游标
       fetch temp_salary_cursor into v_salary;
      loop 
       IF(v_salary > 3000)THEN dbms_output.put_line('< employee Name> earn…'|| v_salary);
       ELSE dbms_output.put_line('< employee Name>  s salary updated' || v_salary);
       END IF;
       END LOOP;
       END;     
       --------------------------------------------------------------------------
     DECLARE
     v_last_name employees.last_name%type;
      CURSOR emp_cursor IS
         SELECT last_name,salary
           FROM employees;
        BEGIN
      FOR emp_record IN emp_cursor LOOP
      -- implicit open and implicit fetch occur
      IF (emp_record.salary > 3000) THEN
      dbms_output.put_line(  emp_record.last_name  ||'earn…'|| emp_record.salary);
      ELSE
      update employees set salary= salary+500;
      dbms_output.put_line(  emp_record.last_name  ||'salary updated');
      END IF;
      END LOOP; -- implicit close occurs
      END;  
      
      select * from employees
             
 /*
     8.   将员工的工资存储在iSQL*Plus替换变量中。
            b.编写一个PL/SQL块来使用上面定义的工资并执行以下操作:
            计算年薪为工资* 12。
            计算奖金如下:
 */      
       DECLARE
       cursor emp_cursor is  
       select Last_name,salary 
       from employees;
       begin
       FOR emp_record IN emp_cursor LOOP
       IF(emp_record.salary>=20000) THEN 
       dbms_output.put_line( EMP_record.last_name||'奖金为'|| '2000');
       ELSIF(emp_record.salary<20000 and emp_record.salary>=10000) THEN
       DBMS_OUTPUT.put_line(EMP_record.last_name||'奖金为'|| '1000');
       ELSE  DBMS_OUTPUT.put_line(EMP_record.last_name||'奖金为'|| '500');
       END IF;
       END LOOP;
       END;
       
       
       
       /*
           9.
             a.编写一个PL/SQL块来存储一个员工编号、新的部门编号和iSQL*加上替换变量中工资增长的百分比。
             
             b.用新部门号更新员工部门ID，用新工资更新工资。使用EMP表进行更新。更新完成后，在窗口中显示“更新完成”消息。
              如果没有找到匹配的记录，则显示“没有找到数据”。测试下列测试用例的PL/SQL:
       */
       
       
       b
       DECLARE
       v_EMPID employees.employee_id%type := &empID;
       v_deptID employees.department_id%type := &deptID;
       v_add number(9,2) := &v_add;
       BEGIN 
       update employees set department_id=v_deptID,salary = salary + (salary* v_add/100)
       where employee_id = v_EMPID;
       IF SQL%ROWCOUNT = 0 THEN 
          dbms_output.put_line('没找到');
       ELSE
          dbms_output.put_line('找到了');
       END IF;
       END;   
            
       /*
       10          
       创建PL/SQL块来声明游标EMP_CUR，以从EMPLOYEES表中选择员工姓名、工资和雇佣日期。从游标开始处理每一行，
       如果工资大于15,000，并且雇佣日期大于01-FEB-1988，则在窗口中显示员工姓名、工资和雇佣日期，格式如下面的示例输出所示:
       */ 
       
       如何比日期大小
       DECLARE 
            cursor EMP is 
            select last_name,salary,hire_date 
            from employees;
       BEGIN 
         FOR emp_record IN EMP LOOP
         IF(emp_record.salary>15000 and to_date(emp_record.hire_date,'dd-MON-yyyy')>to_date('01-FEB-1988','dd-MON-yyyy')) THEN 
         dbms_output.put_line(emp_record.last_name || emp_record.salary || emp_record.hire_date);
         END IF;
         END LOOP;
         END; 
         
         /*
          11.
            为EMPLOYEE_ID小于114的员工创建一个PL/SQL块，从EMPLOYEES表中检索每个员工的姓和部门ID。从EMPLOYEES表检索的值中，填充两个PL/SQL表，
            一个用于存储员工姓的记录，另一个用于存储部门id的记录。使用循环，从PL/SQL表中检索员工姓名信息和工资信息，并使用DBMS_OUTPUT.PUT_LINE将其显示在窗口中。
            在PL/SQL表中显示前15名员工的这些详细信息。
         */
         
         DECLARE 
             cursor EMP is 
             select last_name  
          
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       


select * from employees where employee_id =102

declare
  grade char(1) := 'A';
begin
  case grade
    when 'A' then dbms_output.put_line('A');
    when 'B' then dbms_output.put_line('B');
    else dbms_output.put_line('NO');
  end case;
end;



DECLARE
  v_sal NUMBER(9, 2) := &p_annual_sal;
BEGIN
  v_sal := v_sal / 12;
  DBMS_OUTPUT.PUT_LINE('The monthly salary is ' || TO_CHAR(v_sal));
END;





-- if elae  je
DECLARE
    a number(3) := 100;
BEGIN
    IF ( a = 10 ) THEN
        dbms_output.put_line('Value of a is 10' );
    ELSIF ( a = 20 ) THEN
        dbms_output.put_line('Value of a is 20' );
    ELSIF ( a = 30 ) THEN
        dbms_output.put_line('Value of a is 30' );
    ELSE
        dbms_output.put_line('None of the values is matching');
    END IF;
    dbms_output.put_line('Exact value of a is: '|| a );
END;





--游标练习


DECLARE
CURSOR sal_cursor IS
SELECT e.department_id, employee_id, last_name, salary
FROM employees e, departments d
WHERE d.department_id = e.department_id
and d.department_id = 60
FOR UPDATE OF salary NOWAIT;
BEGIN
FOR emp_record IN sal_cursor
LOOP
IF emp_record.salary < 5000 THEN
UPDATE employees
SET salary = emp_record.salary * 1.10
WHERE CURRENT OF sal_cursor;
END IF;
END LOOP;
END;





DECLARE
    -- Global variables
    num1 number := 95;
    num2 number := 85;
BEGIN
    dbms_output.put_line('Outer Variable num1: ' || num1);
    dbms_output.put_line('Outer Variable num2: ' || num2);
END;


   