---



---

# 单车变摩托——java



[TOC]





## JavaCore







### 细碎知识点：

1.局部内部类是否可以访问非final变量？

答：不能访问局部的非final变量，但是可以访问全局的。

2.局部变量前不能放置任何访问修饰符 (private，public，和protected)。final可以用来修饰局部变量

3.final修饰的变量在**使用前**必须进行初始化   可以在声明时直接进行初始化 或者在构造方法中初始化

4.接口中的变量默认为public static final

5.调用本类构造器 不能使用      “构造方法()/类名()”这种格式 

6.正确的native方法命名格式：权限修饰符  native  返回值 方法名();

7.外部类只能使用public、final或者不加访问修饰符。

8.FilterInputStream构造方法的参数只有inputStream

9.方法void flush()是**缓冲输出流**的基本方法，作用是强制将流缓冲区中的当前内容强制输出。

10.javaAPI中不包括父类的方法列表     

类文档的内容主要是：类层次、类及用途描述、成员变量列表、构造方法列表、成员方法列表、从类层次上继承的方法列表、成员变量的详细说明、构造方法详细说明、成员方法详细说明。 

11.java和javasciprt的区别(Core Java)

答：javascript与Java是两个公司开发的不同的两个产品。Java是SUN公司推出的新一代面向对象的程序设计语言，特别适合于Internet应用程序开发；而javascript是Netscape公司的产品，其目的是为了扩展Netscape Navigator功能,而开发的一种可以嵌入Web页面中的基于对象和事件驱动的解释性语言, 它的前身是Live Script；而Java的前身是Oak语言。下面对两种语言间的异同作如下比较：
 1）基于对象和面向对象：
 Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象。 
 javascript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object Based）和事件驱动（Event Driver）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用。 
 2）解释和编译：
 Java的源代码在执行之前，必须经过编译；
 javascript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。 
 3）强类型变量和类型弱变量：
 Java采用强类型变量检查，即所有变量在编译之前必须作声明； 
 javascript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型。
 4）代码格式不一样。

​     

5.钓友本类中的

###  权限访问控制符：

| 修饰符    | 说明                                                     |
| :-------- | :------------------------------------------------------- |
| private   | 私有的，在同一类内可见。                                 |
| 默认没写  | 在同一包(包括子类和非子类)内可见。默认不使用任何修饰符。 |
| protected | 受保护的，对同一包内的类和所有子类可见。                 |
| public    | 共有的，对所有类可见。                                   |

特殊情况：

（1）这里的可见、可访问指的是能不能通过 ”类的对象.变量名“的方式访问，这是因为除static声明的变量属于类变量外，其他的都属于实例变量，是属于某个对象的！
如，Person p = new Person(); p.age直接访问age变量，对于那些私有的变量，很多情况下会对外提供public的setter和getter方法来供外部访问。

（2）要注意的是，对于有继承关系的子类来说，比如 class A extends B，A直接继承拥有了默认的(在同一包下)、protected、public的这个字段，可以直接使用该字段，而不用通过再次的实例化父类或"父类对象.字段"的形式访问，因为在实例化A类的时候父类B已经实例化好了。特别的，对于protected来说，如下形式是编译不能通过的。

```java
package com.a
public class A extends B{
    public void test(){
        B b = new B();
        String str = b.age;//错误！不同包下的子类不能通过实例出来的父类获取protected的变量
        String str2 = age;//正确，A类继承了B，直接拥有了该字段
        String str3 = b.birthday;//正确，birthday为public
    }
}
package com.b
public class B{
    protected String age = "20";
    public String birthday = "1995";

## }
```

### UTF-8和GBK编码转换

​    

    下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：byte[] src,dst;
    
    A、dst=String.fromBytes(src，"GBK").getBytes("UTF-8")
    B、dst=new String(src，"GBK").getBytes("UTF-8")
    C、dst=new String("GBK"，src).getBytes()
    D、dst=String.encode(String.decode(src，"GBK"))，"UTF-8" )

正确答案：B

​    操作步骤就是先解码再编码，先通过GBK编码还原字符串，在该字符串正确的基础上得到“UTF-8”所对应的字节串。

### Java基本数据类型及包装类

byte(字节)              8 位               Byte
shot(短整型)          16位               Short
int(整型)                32 位              Integer
long(长整型)         64 位               Long
float(浮点型)         32 位               Float
double(双精度)     64 位               Double
char(字符型)          16 位               Character
boolean(布尔型)    1 位                Boolean

各数据类型按容量大小（表数范围大小）由小到大排列为：

     byte <—— short, char  <——int <——long <——float <——double

基本类型之间的转换原则：

    1）运算时，容量小的类型自动转换为容量大的类型；
    
    2）容量大的类型转换为容量小的类型时，要加强制转换符，且精度可能丢失；
            如：float f = 1.2f;
            int ff = (int) f;
            System.out.println(ff);//输出为1，丢掉了小数部分
            
    3）short，char之间不会互相转换（需要强制转换），byte、short、char并且三者在计算时首先转换为int类型；
    
    4）实数常量默认为double类型， 整数常量默认为int类型；
### 关于null对象、static变量和方法

```
有关下述Java代码描述正确的选项是____。
publicclassTestClass {
   privatestaticvoidtestMethod(){
        System.out.println("testMethod");
   }
   publicstaticvoidmain(String[] args) {
        ((TestClass)null).testMethod();
   }
}
        A、编译不通过
        B、编译通过，运行异常，报NullPointerException
        C、编译通过，运行异常，报IllegalArgumentException
        D、编译通过，运行异常，报NoSuchMethodException
        E、编译通过，运行异常，报Exception
        F、运行正常，输出testMethod

正确答案：F
```



静态方法是属于类的，静态方法在对象实例创建前就已经存在了，它的使用不依赖于对象是否被创建。当我们通过类的实例来调用时，最后实际上还是将对象实例转换成了类去掉用该静态方法，所以这里的null只是迷惑大家的跟它没有什么关系。
这里 ((TestClass)null).testMethod();也可以写成TestClass t = null; t.testMethod();同样可以正确输出。null可以被强制转换成任意类型对象，虽然这个时候t被赋为了空，但这个“空对象”也是属于TestClass的，那么这个“空对象”也就可以去堆上的静态方法区调用testMethod()方法了。
如果这里testMethod把static去掉，该testMethod方法就变成了实例对象的方法了。这时，可以编译通过，但是会报空指针。

同理，对于static变量也是一样的。比如TestClass 中有如下变量：private static String str = "abc"; 我们通过TestClass t = null; System.out.println(t.str);同样可以正确输出。

### equals与==的区别

（1）==是一个运算符，它比较的是值
    对于基本数据类型，直接比较其数据值是否相等。如果是不同的基本数据类型之间进行比较，则遵循基本数据类型间运算的转换原则（见上面总结的第二条）。如下：
        
if(12 == 12.0){
	System.out.println("-----12 == 12.0-------");
}

此时打印了-----12 == 12.0-------，因为低一级的int类型的12自动转换为高一级的float类型

    对于引用类型，==比较的还是值，只不过此时比较的是两个对象变量的内存地址。所以，用==来比较对象，实际上是判断这两个对象是否是同一个new出来的对象，或者是否是一个对象赋值给另一个对象的情况。如：String s1 = new String("abc");
              String s2 = s1;//将s1对的内存地址赋给了s2，此时s1==s2返回true；

（2）equals
equals方法是属于Object类的一个方法，其实现源码如下：

public boolean equals(Object obj) {
	return (this == obj);
}
可以看到，其实equals方法里面用的还是==运算符，所以对于那些没有重写过Object类的equals方法来说，==和equals方法是等价的！
然而，很多类都自己去重写了equals方法，比如String类、所有基本数据类型的包装类等
String类的equals源码如下：
    

```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String) anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                        return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

首先判断是否是同一个new出来的对象，即判断内存地址是否相同；如果不同则判断对象中的内容是否相同。
Integer类的equals方法如下：

    public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }

直接转成判断值是否相等了。
因此，对于String类和所有基本数据类型的包装类来说，equals方法就是判断其内容是否相等。对于其他类来说，要具体看其是否重写了equals方法及具体业务实现。

另：对于基本数据类型来说，使用equals方法，需要用该基本类型对应的包装类，因为equals是针对对象来使用的！



Object有哪些公用方法
Object类中的所有方法如下：

```
public boolean equals(Object obj) {//判断是否同一个对象，具体见上一点总结
    return (this == obj);
}

public String toString(){
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}

//返回该对象的哈希码值，重写了equals方法一般都要重写hashCode方法
public native int hashCode();

/**
*wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
*调用该方法后当前线程进入睡眠状态，直到以下事件发生。
*（1）其他线程调用了该对象的notify方法。
*（2）其他线程调用了该对象的notifyAll方法。
*（3）其他线程调用了interrupt中断该线程。
*（4）时间间隔到了。
*此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。
*如：Person p = new Person();
*p.wait()//使用Person p对象作为对象锁。
*/
public final void wait() throws InterruptedException {...}

public final native void wait(long timeout) throws InterruptedException;

public final void wait(long timeout, int nanos) throws InterruptedException {...}

//该方法唤醒在该对象上等待的某个线程。如p.notify();
public final native void notify();

//该方法唤醒在该对象上等待的所有线程。
public final native void notifyAll();

public final native Class<?> getClass();//获得运行时类型

//创建并返回此对象的一个副本。只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。
protected native Object clone() throws CloneNotSupportedException;

//用于释放资源。当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。也可手动调用，自己实现一些资源的释放。
 protected void finalize() throws Throwable { }
```



### interface与abstract类的区别

抽象方法必须定义在抽象类里面  抽象类中可以没有抽象方法

在Java8之后 接口中可以定义普通方法 但必须使用default进行修饰



​    abstract class 只能被继承（extends），体现的是一种继承关系，而根据继承的特征，有继承关系的子类和父类应该是一种“is-a”的关系，也即两者在本质上应该是相同的（有共同的属性特征）。
​    interface 是用来实现的（implements），它并不要求实现者和interface之间在本质上相同，是一种“like-a”的关系，interface只是定义了一系列的约定而已（实现者表示愿意遵守这些约定）。所以一个类可以去实现多个interface（即该类遵守了多种约定）。
​    很多情况下interface和abstract都能满足我们要求，在我们选择用abstract或interface的时候，尽量符合上面的要求，即如果两者间本质是一样的，是一种“is-a”的关系，尽量用abstract，当两者之间本质不同只是简单的约定行为的话，可以选择interface。
特点：
（1）abstract类其实和普通类一样，拥有有自己的数据成员和方法，只不过abstract类里面可以定义抽象abstract的方法（声明为abstract的类也可以不定义abstract的方法，直接当做普通类使用，但是这样就失去了抽象类的意义）。
（2）一个类中声明了abstract的方法，该类必须声明为abstract类。

（3）interface中只能定义常量和抽象方法。在接口中，我们定义的变量默认为public static final类型，所以不可以在显示类中修改interface中的变量；定义的方法默认为public abstract，其中abstract可以不明确写出。



### Final修饰符、volatile修饰符

Final修饰符，用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法可以被继承，重载，但是不能被子类重写（即重新定义）

```
（1）final变量：
被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变。也就是说final对象的引用不能改变，但是里面的值可以改变。比如：
        final Person p = new Person();
        p.name = "aaa";
        p.name = "bbb";
但是，如果是final String str = "aaa";     str = "bbb";//错误编译不能通过，因为此时str的引用已经改变了！

（2）final修饰方法
Final修饰的方法可以被子类继承，但是不能被子类修改（重写）。

声明final方法的主要目的是防止该方法的内容被修改。


```

volatile修饰符，Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。

### StringBuffer 和 StringBuilder（线程不安全）

和String类不同，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生新的未使用对象。
StringBuilder类和StringBuffer之间的最大不同在于StringBuilder的方法不是线程安全的（不能同步访问）。

由于StringBuilder相较于StringBuffer有速度优势，所以多数情况下建议使用StringBuilder类。然而在应用程序要求线程安全的情况下，则必须使用StringBuffer类。

可变长参数只能有一个且只能存在于参数列表的最后位置



### Java中的四种引用：强引用、软引用、弱引用、虚引用

四种级别由高到低依次为：强引用 > 软引用 > 弱引用 > 虚引用

#### 强引用：

我们平时new 出来的对象都是强引用  

如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题

定义方式：

```
    String str = new String("abc");    //强引用，在堆中创建了      String这个对象，通过栈中的变量str引用这个对象
   String str2 = str;    //强引用，str2也指向了堆中创建的         String对象
```

#### 软引用（SoftReference）：

   如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

声明方法：

```
	  String str= new String("abc");     //强引用   
	   Reference  sr = new SoftReference(str);    //软引用    
	    //引用时    
	    if(sr!=null){    
	        str= (String) sr.get();    
	    }else{    
	        str= new String("abc");    
	        sr = new SoftReference(str);    
	   }

```

可以看到不论是强引用、软引用、弱引用或者虚引用都是针对某个对象来说的，当我们某个对象需要设置为软引用时，只需要给该对象套入到软引用对象中即可，如上面的代码SoftReference sr = new SoftReference(str);  

####  弱引用（WeakReference）

​    弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

声明方法

```
String str = new String("abc");
        WeakReference<String> soft = new WeakReference<String>(str);    //弱引用
        str = null;
        System.out.println("before gc:" + soft.get());
        System.gc();

      System.out.println("after gc:" + soft.get());
```

输出结果：before gc :abc
                 after gc: null

因此可以看出，软引用和弱引用被gc回收的过程是一致的，但是最后到底会不会回收掉该对象，要分情况。对于软引用来说，如果内存不足的情况下才会回收掉；对于弱引用来说，只要gc准备回收该弱引用对象，就会被立即释放掉

####  虚引用（PhantomReference）：

在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。

![](F:\briup\大数据\随笔\images\Java中的四种引用.png)





### Override和Overload的区别

#### Override（重写）:    

​    在子类中定义与父类具有完全相同的名称和参数的方法，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，是子类与父类之间多态性的一种体现。特点如下：
  （1）子类方法的访问权限只能比父类的更大，不能更小（可以相同）；
  （2）如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法；
  （3）子类覆盖的方法所抛出的异常必须和父类被覆盖方法的所抛出的异常一致，或者是其子类；即子类的异常要少于父类被覆盖方法的异常；

#### Overload（重载）:

​    （参考文章：http://developer.51cto.com/art/201106/266705.htm）  
  同一个类中可以有多个名称相同的方法，但方法的参数个数和参数类型或者参数顺序不同；
​    关于重载函数返回类型能否不一样，需分情况：
（1）如果几个Overloaded的方法的参数列表不一样（个数或类型），它们的返回者类型当然也可以不一样；
（2）两个方法的参数列表完全一样，则不能通过让其返回类型的不同来实现重载。

（3）不同的参数顺序也是可以实现重载的









### 关于hashCode方法

​    【参考文章：
​          http://www.cnblogs.com/dolphin0520/p/3681042.html
​    】
​    我们可以先通过HashMap中hashCode的作用来体验一下。
​    我们知道HashMap中是不允许插入重复元素的，如果是插入的同一个元素，会将前面的元素给覆盖掉，那势必在HashMap的put方法里对key值进行了判断，检测其是否是同一个对象。其put源码如下：    

```
  public V put(K key, V value) {
        if (table == EMPTY_TABLE) {    //key的hashCode值放在了table里面
            inflateTable(threshold);
        }
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);    //计算我们传进来的key的hashcode值
        int i = indexFor(hash, table.length);
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {    //将传进来的key的hashcode值于HashMap中的table里面存放的hashCode值比较
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }
```

​    可以看到这里的判断语句 if (e.hash == hash && ((k = e.key) == key || key.equals(k)))，里面通过&&逻辑运算符相连，先判断e.hash == hash，即判断传进来的key的hashCode值与table中的已有的hashCode值比较，如果不存在该key值，也就不会再去执行&&后面的equals判断；当已经存在该key值时，再调用equals方法再次确定两个key值对象是否相同。从这里可以看出，
$$
hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率
$$
。    可以看到，判断两个对象是否相同，还是要取决于equals方法，而两个对象的hashCode值是否相等是两个对象是否相同的必要条件。所以有以下结论：
    （1）如果两个对象的hashCode值不等，根据必要条件理论，那么这两个对象一定不是同一个对象，即他们的equals方法一定要返回false；
    （2）如果两个对象的hashCode值相等，这两个对象也不一定是同一个对象，即他们的equals方法返回值不确定；
    反过来，
    （1）如果equals方法返回true，即是同一个对象，它们的hashCode值一定相等；
    （2）如果equals方法返回false，hashCode值也不一定不相等，即是不确定的；

​    可以看到这里的判断语句 if (e.hash == hash && ((k = e.key) == key || key.equals(k)))，里面通过&&逻辑运算符相连，先判断e.hash == hash，即判断传进来的key的hashCode值与table中的已有的hashCode值比较，如果不存在该key值，也就不会再去执行&&后面的equals判断；当已经存在该key值时，再调用equals方法再次确定两个key值对象是否相同。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。
​    可以看到，判断两个对象是否相同，还是要取决于equals方法，而两个对象的hashCode值是否相等是两个对象是否相同的必要条件。所以有以下结论：
​    （1）如果两个对象的hashCode值不等，根据必要条件理论，那么这两个对象一定不是同一个对象，即他们的equals方法一定要返回false；
​    （2）如果两个对象的hashCode值相等，这两个对象也不一定是同一个对象，即他们的equals方法返回值不确定；
​    反过来，
​    （1）如果equals方法返回true，即是同一个对象，它们的hashCode值一定相等；
​    （2）如果equals方法返回false，hashCode值也不一定不相等，即是不确定的；

（hashCode返回的值一般是对象的存储地址或者与对象存储地址相关联的hash散列值）

然而，很多时候我们可能会重写equals方法，来判断这两个对象是否相等，此时，为了保证满足上面的结论，即满足hashCode值相等是equals返回true的必要条件，我们也需要重写hashCode方法，以保证判断两个对象的逻辑一致（所谓的逻辑一致，是指equals和hashCode方法都是用来判断对象是否相等）。如下例子：

```
public class Person {
    private String name;
    private int age;
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }


@Override
public boolean equals(Object obj) {
    return this.name.equals(((Person)obj).name) && this.age== ((Person)obj).age;
}

}
```

在Person里面重写了equals方法，但是没有重写hashCode方法，如果就我们平时正常来使用的话也不会出什么问题，如：    

在Person里面重写了equals方法，但是没有重写hashCode方法，如果就我们平时正常来使用的话也不会出什么问题，如：    

```
   Person p1 = new Person("lly",18);
    Person p2 = new Person("lly",18);
    System.out.println(p1.equals(p2));    //返回true
```

上面是按照了我们重写的equals方法，返回了我们想要的值。但是当我们使用HashMap来保存Person对象的时候就会出问题了，如下：        


上面是按照了我们重写的equals方法，返回了我们想要的值。但是当我们使用HashMap来保存Person对象的时候就会出问题了，如下：        
<span style="white-space:pre">	</span>

```
Person p1 = new Person("lly", 18);
        System.out.println(p1.hashCode());
        HashMap<Person, Integer> hashMap = new HashMap<Person, Integer>();
        hashMap.put(p1, 1);
        System.out.println(hashMap.get(new Person("lly", 18)));    //此时返回了null，没有按我们的意愿返回1
```

​    这是因为，我们没有重写Person的hashCode方法，使hashCode方法与我们equals方法的逻辑功能一致，此时的Person对象调用的hashCode方法还是父类的默认实现，即返回的是和对象内存地址相关的int值，这个时候，p1对象和new Person("lly",18);对象因为内存地址不一致，所以其hashCode返回值也是不同的。故HashMap会认为这是两个不同的key，故返回null。
​    所以，我们想要正确的结果，只需要重写hashCode方法，让equals方法和hashCode方法始终在逻辑上保持一致性。

在《Java编程思想》一书中的P495页有如下的一段话：

　　“设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在将一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码”。

如下一个例子：

```

public class Person {
    private String name;
    private int age;
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public int hashCode() {
        return name.hashCode()*37+age;    //hashCode的返回值依赖于对象中的易变数据
    }
    @Override
    public boolean equals(Object obj) {
        return this.name.equals(((Person)obj).name) && this.age== ((Person)obj).age;
    }
}

```

此时我们继续测试：        

```
Person p1 = new Person("lly", 18);
        System.out.println(p1.hashCode());
        HashMap<Person, Integer> hashMap = new HashMap<Person, Integer>();
        hashMap.put(p1, 1);
       p1.setAge(13);//改变依赖的一个值
        System.out.println(hashMap.get(p1));    //此时还是返回为null,这是因为我们p1的hashCode值已经改变了
```

所以，在设计hashCode方法和equals方法的时候，如果对象中的数据易变，则最好在hashCode方法中不要依赖于该字段。





### OOM你遇到过哪些情况，SOF你遇到过哪些情况

####     OOM：OutOfMemoryError异常，

​    即内存溢出，是指程序在申请内存时，没有足够的空间供其使用，出现了Out Of Memory，也就是要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。
​    内存溢出分为上溢和下溢，比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。
​    

有时候内存泄露会导致内存溢出，所谓内存泄露（memory leak），是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，举个例子，就是说系统的篮子（内存）是有限的，而你申请了一个篮子，拿到之后没有归还（忘记还了或是丢了），于是造成一次内存泄漏。在你需要用篮子的时候，又去申请，如此反复，最终系统的篮子无法满足你的需求，最终会由内存泄漏造成内存溢出。

#### 遇到的OOM：

##### （1）Java Heap 溢出

Java堆用于存储对象实例，我们只要不断的创建对象，而又没有及时回收这些对象（即内存泄漏），就会在对象数量达到最大堆容量限制后产生内存溢出异常。

##### （2）方法区溢出

   方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。
异常信息：java.lang.OutOfMemoryError:PermGen space

方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。

#### SOF：StackOverflow（堆栈溢出）

​    当应用程序递归太深而发生堆栈溢出时，抛出该错误。因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。

#####     栈溢出的原因：

​    （1）递归调用
​    （2）大量循环或死循环
​    （3）全局变量是否过多
​    （4）数组、List、Map数据过大

OOM在Android开发中出现比较多：
   场景有： 加载的图片太多或图片过大时、分配特大的数组、内存相应资源过多没有来不及释放等。

##### 解决方法：

​    （1）在内存引用上做处理
​        软引用是主要用于内存敏感的高速缓存。在jvm报告内存不足之前会清除所有的软引用，这样以来gc就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于gc的算法和gc运行时可用内存的大小。
​    （2）对图片做边界压缩，配合软引用使用
​    （3）显示的调用GC来回收内存，如：
​        if(bitmapObject.isRecycled()==false) //如果没有回收  
​       bitmapObject.recycle();
  （4）优化Dalvik虚拟机的堆内存分配
​            》增强程序堆内存的处理效率    
​        //在程序onCreate时就可以调用 即可
​        privatefinalstaticfloat TARGET_HEAP_UTILIZATION = 0.75f; 
​        VMRuntime.getRuntime().setTargetHeapUtilization(TARGET_HEAP_UTILIZATION);

​        》设置堆内存的大小
​        privatefinalstaticintCWJ_HEAP_SIZE = 6* 1024* 1024;
  //设置最小heap内存为6MB大小
  VMRuntime.getRuntime().setMinimumHeapSize(CWJ_HEAP_SIZE);

（5）用LruCache 和 AsyncTask<>解决
    从cache中去取Bitmap，如果取到Bitmap，就直接把这个Bitmap设置到ImageView上面。

　　如果缓存中不存在，那么启动一个task去加载（可能从文件来，也可能从网络）。







### Java面向对象的三个特征与含义，多态的实现方式

Java中两个非常重要的概念：类和对象。类可以看做是一个模板，描述了一类对象的属性和行为；而对象是类的一个具体实现。Java面向对象的三大基本特征：

#### （1）封装

​    属性用来描述同一类事物的特征，行为用来描述同一类事物可做的一些操作。封装就是把属于同一类事物的共性（属性和行为）归到一个类中，只保留有限的接口和方法与外部进行交互，避免了外界对对象内部属性的破坏。Java中使用访问控制符来保护对类、属性、方法的访问。

#### （2）继承

​    子类通过这种方式来接收父类所有的非private的属性和方法（构造方法除外）。这里的接收是直接拥有的意思，即可以直接使用父类字段和方法，因此，继承相当于“扩展”，子类在拥有了父类的属性和特征后，可以专心实现自己特有的功能。
​    （构造方法不能被继承，因为在创建子类时，会先去自动“调用”父类的构造方法，如果真的需要子类构造函数特殊的形式，子类直接修改或重载自己的构造函数就好了。）

#### （3）多态

多态解除类型耦合：

![](F:\briup\大数据\随笔\images\多态——解耦.png)

多态存在的三个必要条件 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。



​    多态是程序在运行的过程中，同一种类型在不同的条件下表现不同的结果。比如：
​        Animal  a = new Dog();    // 子类对象当做父类对象来使用，运行时，根据对象的实际类型去找子类覆盖之后的方法

多态实现方式：
    （1）设计时多态，通过方法的重载实现多态；（编译时多态）

   （2）运行时多态，通过重写父类或接口的方法实现运行时多态











------





## Java高级

### 关于异常分类

所有的异常类是从java.lang.Exception类继承的子类。

Exception类是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error 。Error用来指示运行时环境发生的错误。层次关系如图：

![](F:\briup\大数据\随笔\images\异常分类图.jpg)

```
检查性异常: 不处理编译不能通过
非检查性异常：不处理编译可以通过，如果有抛出直接抛到控制台。
运行时异常（RuntimeException）： 继承自RuntimeException类的就是非检查性异常
非运行时异常： 就是检查性异常
```

异常	描述
ArithmeticException	当出现异常的运算条件时，抛出此异常。例如，一个整数"除以零"时，抛出此类的一个实例。
ArrayIndexOutOfBoundsException	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。
ArrayStoreException	试图将错误类型的对象存储到一个对象数组时抛出的异常。
ClassCastException	当试图将对象强制转换为不是实例的子类时，抛出该异常。
IllegalArgumentException	抛出的异常表明向方法传递了一个不合法或不正确的参数。
IllegalMonitorStateException	抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。
IllegalStateException	在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。
IllegalThreadStateException	线程没有处于请求操作所要求的适当状态时抛出的异常。
IndexOutOfBoundsException	指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。
NegativeArraySizeException	如果应用程序试图创建大小为负的数组，则抛出该异常。
NullPointerException	当应用程序试图在需要对象的地方使用 null 时，抛出该异常
NumberFormatException	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
SecurityException	由安全管理器抛出的异常，指示存在安全侵犯。
StringIndexOutOfBoundsException	此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。
UnsupportedOperationException	当不支持请求的操作时，抛出该异常。



下面的表中列出了Java定义在java.lang包中的检查性异常类。(检查型异常即在编写代码过程中必须处理或抛出的异常)

| 异常                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ClassNotFoundException     | 应用程序试图加载类时，找不到相应的类，抛出该异常。           |
| CloneNotSupportedException | 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。 |
| IllegalAccessException     | 拒绝访问一个类的时候，抛出该异常。                           |
| InstantiationException     | 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。 |
| InterruptedException       | 一个线程被另一个线程中断，抛出该异常。                       |
| NoSuchFieldException       | 请求的变量不存在                                             |
| NoSuchMethodException      | 请求的方法不存在                                             |
|                            |                                                              |



### List集合遍历删除问题：

1.1、会报错的删除方式：
（1）在Iterator遍历时使用list删除

```
 Iterator<String> it = list.iterator();
        while(it.hasNext()){
            String item = it.next();
            list.remove(item);    //报错！！！
 }
```

（2）foreach遍历方式中删除

```
 for(String s : list){
           list.remove(s); //报错！！！
 }
```

以上都是报java.util.ConcurrentModificationException，某个线程在 Collection 上进行迭代时，通常不允许另一个线性修改该 Collection，因为在这些情况下，迭代的结果是不确定的。

而对于foreach实际上使用的是iterator进行处理的，而iterator是不允许集合在iterator使用期间通过list删除的，也就是第一种方式，也就是说上面两种方式相当于是同一种。



1.2、不会报错，但是有可能漏删或不能完全的删除方式：
（1）漏删的情况（通过索引下标的方式）
       

```
List<Integer> list = new ArrayList<Integer>();
list.add(1);
list.add(2);
list.add(2);
list.add(3);
list.add(4);
System.out.println("----------list大小1：--"+list.size());
for (int i = 0; i < list.size(); i++) {
	if (2 == list.get(i)) {
		list.remove(i);    
	}
	System.out.println(list.get(i));
}
System.out.println("最后输出=" + list.toString());   
```

输出的结果如下：
----------list大小1：--5
1
2
3
4
最后输出=[1, 2, 3, 4]
可以看到，只删除了一个2，还有一个没有完全删除，原因是：删除了第一个2后，集合里的元素个数减1，后面的元素往前移了1位，此时，第二个2已经移到了索引index=1的位置，而此时i马上i++了，list.get(i)获得的是数据3。

（2）不能完全删除的情况

```
List<Integer> list = new ArrayList<Integer>();
list.add(1);
list.add(2);
list.add(2);
list.add(3);
list.add(4);
System.out.println("----------list大小1：--"+list.size());
for (int i = 0; i < list.size(); i++) {
	list.remove(i);
}
System.out.println("最后输出=" + list.toString());
```

输出的结果如下：
----------list大小1：--5
最后输出=[2, 3]
可以看到，结果并没有按照我们的想法，把所有数据都删除干净。原因是：在list.remove之后，list的大小发生了变化，也就是list.size()一直在变小，而 i 却一直在加大，当 i =3时，list.size()=2，此时循环的判断条件不满足，退出了程序。

以上两种情况通过for循环遍历删除，都没有正确达到目的，都是因为在remove后list.size()发生了变化（一直在减少），同时后面的元素会往前移动，导致list中的索引index指向的数据有变化。同时我们的for中的i是一直在加大的！



1.3 List遍历过程中删除元素的推荐做法

还是使用Iterator遍历，但是不用list来remove。如下代码：
       

```
List<Integer> list = new ArrayList<Integer>();
list.add(1);
list.add(2);
list.add(2);
list.add(3);
list.add(4);
System.out.println("----------list大小1：--"+list.size());
Iterator<Integer> it = list.iterator();
while(it.hasNext()){
	Integer item = it.next();
	if (2 == item) {
		it.remove();
	}
	System.out.println(item);
}
System.out.println("最后输出=" + list.toString());
```

输出结果：
----------list大小1：--5
1
2
2
3
4
最后输出=[1, 3, 4]
此时，两个2被全部删除了。
对于iterator的remove()方法，也有需要我们注意的地方：

1、每调用一次iterator.next()方法，只能调用一次remove()方法。

2、调用remove()方法前，必须调用过一次next()方法。

本人拙见： 使用addAll和removeAll进行增加和删除   在操作过程中使用一个临时    			集合进行储存

```
 List<Integer> list = new ArrayList<Integer>();
	  ArrayList<Object> temp = new ArrayList<>();
	  list.add(1);
	  list.add(2);
	  list.add(2);
	  list.add(3);
	  list.add(4);
	  System.out.println("----------list大小1：--"+list.size());
	  Iterator<Integer> it = list.iterator();
	  while(it.hasNext()){
	  	Integer item = it.next();
	  	if (2 == item) {
	  		temp.add(item);
	  	}
	  	System.out.println(item);
	  }
	  list.removeAll(temp);
	  System.out.println("最后输出=" + list.toString());


```



### 其他

1、下面描述属于java虚拟机功能的是？
A、通过 ClassLoader 寻找和装载 class 文件
B、解释字节码成为指令并执行，提供 class 文件的运行环境
C、进行运行期间垃圾回收
D、提供与硬件交互的平台
正确答案：ABCD

2、下面有关java threadlocal说法正确的有？
A、ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递
B、线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收
C、在Thread类中有一个Map，用于存储每一个线程的变量的副本。
D、对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式

正确答案：ABCD

```
    ThreadLocal类用于创建一个线程本地变量
    在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值就是变量的副本，ThreadLocal为每一个使用该变量的线程都提供了一个变量值的副本，每一个线程都可以独立地改变自己的副本，是线程隔离的。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。
    ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。
```

以下集合对象中哪几个是线程安全的？( )
A、ArrayList
B、Vector
C、Hashtable
D、Stack
正确答案：BCD
在集合框架中，有些类是线程安全的，这些都是jdk1.1中的出现的。在jdk1.2之后，就出现许许多多非线程安全的类。 下面是这些线程安全的同步的类：

```
vector：比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
statck：堆栈类，继承了Vector
hashtable：比hashmap多了个线程安全
enumeration：枚举，相当于迭代器
除了这些之外，其他的都是非线程安全的类和接口。比如常用的ArrayList、HashMap都是线程不安全的。
```

### 	

**向Set中添加元素问题**：if条件中的添加在代码块添加结束后再添加进set集合

```java
 Set<String> set = new HashSet<>();
            if( set.add("one")){
                if (set.add("two")){
                    if (set.add("three")){
                        set.add("four");
                    }
                }
                for (String s:set) {
                    System.out.println(s);
                }
                
      结果：
        four
        one
        two
        three
```



### Map、Set、List、Queue、Stack的特点与用法

#### List：

​    List集合里面存放的元素有序、可重复。List集合的有序体现在它默认是按照我们的添加顺序设置索引值（即我们可以通过get(索引值index)的方式获取对象）；可重复，是由于我们给每个元素设置了索引值，可以通过索引值找到相应的对象。
​    关于List集合下的具体实现类ArrayList、Vector、LinkedList可以参考上面的第四点总结。对于Statck，它是Vector的子类，模拟了栈后进先出的数据结构。

#### Queue：

​    接口，模拟了队列先进先出的数据结构。

#### Set：

​    Set里面的元素无序、不可重复。由于无序性，我们不能通过get方式获取对象（因为set没有索引值）。如下：        
<span style="white-space:pre">	</span>

```
Set<String> set = new HashSet<String>();
        set.add("ddd");
        set.add("4444");
        set.add("555");
        set.add("777");
        for(String s : set){
            System.out.println(s);
        }
```

​    打印结果如下：
​     ddd
​        777
​        4444
​        555

而对于不可重复性，Set的所有具体实现类其内部都是通过Map的实现类来保存对象的。如HashSet内部就是通过HashMap来保存数据的，如下源码：     

   

```
// Dummy value to associate with an Object in the backing Map--一个没有实际意义的Object对象
    private static final Object PRESENT = new Object();    
    public HashSet() {
        map = new HashMap<>();
    }
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
```


​    可以看到，new出一个HashSet的时候，里面new出了一个HashMap对象，在使用HashSet进行add添加数据的时候，HashSet将我们需要保存的数据作为HashMap 的key值保存了起来，而key值是不允许重复的，相当于HashSet的元素也是不可重复的。

#### Map：

​    以<key,value>键值对的形式保存数据。Map常用类的结构关系如下：

![](F:\briup\大数据\随笔\images\Map及其子类.png)

​    Map里面的元素通过<key,value>键值对的形式保存，不允许重复（具体分析可参考第二点总结内容）。其实Map<key,value>有点像Java中的Model对象类，如下使用：    

```
    class Person{
        private String name;
        private int age;
        //set、get方法省略
    }
    List<Person> persons ;
    //也可使用如下方式
    List<Map<String,String>> persons ; 
    Map<String,String> map = new HashMap<String,String>();
    map.put("name","lly");
    map.put("age","18");
    persons .add(map);
```



### ArrayList、Vector、LinkedList区别：

![](F:\briup\大数据\随笔\images\List接口及其子类.png)



三者都可以添加null元素对象，如下示例：    
    

    ArrayList<String> arrayList = new ArrayList<String>();
        arrayList.add(null);
        arrayList.add(null);
        System.out.println(arrayList.size());    //输出为2
    LinkedList<String> linkedList = new LinkedList<String>();
    linkedList.add(null);
     
    Vector<String> vectorList = new Vector<String>();
    vectorList.add(null);
#### ArrayList和Vector相同点：

ArrayList和Vector两者在功能上基本完全相同，其底层都是通过new出的Object[]数组实现。所以当我们能够预估到数组大小的时候，我们可以指定数组初始化的大小，这样可以减少后期动态扩充数组大小带来的消耗。如下：
ArrayList<String> list= new ArrayList<String>(20);
Vector<String> list2 = new Vector<String>(15);
由于这两者的数据结构为数组，所以在获取数据方面即get()的时候比较高效，而在add()插入或者remove()的时候，由于需要移动元素，效率相对不高。（其实对于我们平常使用来说，由于一般使用add(String element)都是让其加在数组末尾，所以并不需要移动元素，效率还是很好的，如果使用add(int index, String element)指定了插入位置，此时就需要移动元素了。）

#### ArrayList和Vector区别：

在集合容积不足需要扩容的时候

vector增长原来的一倍，而arrayList增长原来的一半

ArrayList的所有方法都不是同步的，而Vector的大部分方法都加了synchronized同步，所以，就线程安全来说，ArrayList不是线程安全的，而Vector是线程安全的，也因此Vector效率方面相较ArrayList就会更低，所以如果我们本身程序就是安全的，ArrayList是更好的选择。

大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。

#### LinkedList:

LinkedList其底层是通过双向循环链表实现的，所以在大量增加或删除元素时（即add和remove操作），由于不需要移动元素有更好的性能，但是在获取数据（get操作）方面要差。

所以，在三者的使用选择上，LinkedList适合于有大量的增加/删除操作和较少随机读取操作，ArrayList适合于大规模随机读取数据，而较少插入和删除元素情景下使用，Vector在要求线程安全的情况下使用。



### HashMap、HashTable、ConcurrentHashMap的区别

​    【参考：http://www.cnblogs.com/carbs/archive/2012/07/04/2576995.html】
​    （关于HashMap的分析，在第三篇总结《Java笔试面试题整理第三波》中的hashCode有分析，同样在这篇中有关于Java容器的介绍。HashMap和HashTable都属于Map类集合。）

#### HashMap和HashTable的区别

HashMap和HashTable都实现了Map接口，里面存放的元素不保证有序，并且不存在相同元素；

区别（线程安全和保存值是否为null方面）：
   （1） HashMap和HashTable在功能上基本相同，但HashMap是线程不安全的，HashTable是线程安全的；

HashMap的put源码如下：    


      public V put(K key, V value) {
            if (table == EMPTY_TABLE) {
                inflateTable(threshold);
            }
            if (key == null)
                return putForNullKey(value);    //说明key和value值都是可以为null
            int hash = hash(key);
            int i = indexFor(hash, table.length);
            for (Entry<K,V> e = table[i]; e != null; e = e.next) {
                Object k;
                if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                    V oldValue = e.value;
                    e.value = value;
                    e.recordAccess(this);
                    return oldValue;
                }
            }
      modCount++;
        addEntry(hash, key, value, i);
        return null;
    }
（2）可以看到，HashMap的key和value都是可以为null的，当get()方法返回null值时，HashMap中可能存在某个key，只不过该key值对应的value为null，也有可能是HashM中不存在该key，所以不能使用get()==null来判断是否存在某个key值，对于HashMap和HashTable，提供了containsKey()方法来判断是否存在某个key。

HashTable的put源码如下：    


     public synchronized V put(K key, V value) {
            // Make sure the value is not null
            if (value == null) {    //当value==null的时候，会抛出异常
                throw new NullPointerException();
            }
     // Makes sure the key is not already in the hashtable.
        Entry tab[] = table;
        int hash = hash(key);
        int index = (hash & 0x7FFFFFFF) % tab.length;
        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) && e.key.equals(key)) {
                V old = e.value;
                e.value = value;
                return old;
            }
        }
     
        modCount++;
        if (count >= threshold) {
            // Rehash the table if the threshold is exceeded
            rehash();
     
            tab = table;
            hash = hash(key);
            index = (hash & 0x7FFFFFFF) % tab.length;
        }
     
        // Creates the new entry.
        Entry<K,V> e = tab[index];
        tab[index] = new Entry<>(hash, key, value, e);
        count++;
        return null;
    }

（3）HashTable是不允许key和value为null的。HashTable中的方法大部分是同步的，因此HashTable是线程安全的。

#### 拓展：

   （1） 影响HashMap（或HashTable）性能的两个因素：初始容量和load factor；
        HashMap中有如下描述：        When the number of entries in the hash table exceeds the product of the load factor and the current capacity, 
the hash table is <i>rehashed</i> (that is, internal data structures are rebuilt) 
        当我们Hash表中数据记录的大小超过当前容量，Hash表会进行rehash操作，其实就是自动扩容，这种操作一般会比较耗时。所以当我们能够预估Hash表大小时，在初始化的时候就尽量指定初始容量，避免中途Hash表重新扩容操作，如：      
 HashMap<String, Integer> map = new HashMap<String, Integer>(20);
        
（类似可以指定容量的还有ArrayList、Vector）

   （2）使用选择上，当我们需要保证线程安全，HashTable优先选择。当我们程序本身就是线程安全的，HashMap是优先选择。
        其实HashTable也只是保证在数据结构层面上的同步，对于整个程序还是需要进行多线程并发控制；在JDK后期版本中，对于HashMap，可以通过Collections获得同步的HashMap；如下：
        Map m = Collections.synchronizedMap(new HashMap(...));
        这种方式获得了具有同步能力的HashMap。        

（3）在JDK1.5以后，出现了ConcurrentHashMap，它可以很好地解决在并发程序中使用HashMap的问题，ConcurrentHashMap和HashTable功能很像，不允许为null的key或value，但它不是通过给方法加synchronized方法进行并发控制的。
 在ConcurrentHashMap中使用分段锁技术Segment，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。效率也比HashTable好的多
​	

### TreeMap、HashMap、LinkedHashMap的区别

​    关于Map集合，前面几篇都有讲过，可以去回顾一下。而TreeMap、HashMap、LinkedHashMap都是Map的一些具体实现类，其关系图如下：

其中，HashMap和HashTable主要区别在线程安全方面和存储null值方面。HashMap前面讨论的已经比较多了，下面说说LinkedHashMap和TreeMap。
（1）LinkedHashMap保存了数据的插入顺序，底层是通过一个双链表的数据结构来维持这个插入顺序的。key和value都可以为null；
（2）TreeMap实现了SortMap接口，它保存的记录是根据键值key排序，默认是按key升序排列。也可以指定排序的Comparator。

HashMap、LinkedHashMap和TreeMap都是线程不安全的，HashTable是线程安全的。

#### 提供两种遍历Map的方法如下：

（1）推荐方式：   遍历entry集合  

```
Map<String, Integer> map = new HashMap<String, Integer>(20);
        for(Map.Entry<String, Integer> entry : map.entrySet()){    //直接遍历出Entry
            System.out.println("key-->"+entry.getKey()+",value-->"+m.get(entry.getValue()));
        }
```

​        这种方式相当于首先通过Set<Map.Entry<String,Integer>> set =  map.entrySet();方式拿到Set集合，而Set集合是可以通过foreach的方式遍历的。

​        这种方式相当于首先通过Set<Map.Entry<String,Integer>> set =  map.entrySet();方式拿到Set集合，而Set集合是可以通过foreach的方式遍历的。

（2） 普通方式：     

```
Map<String, Integer> map = new HashMap<String, Integer>(20);
        Iterator<String> keySet = map.keySet().iterator();    //遍历Hash表中的key值集合，通过key获取value
        while(keySet .hasNext()){
            Object key = keySet .next();
            System.out.println("key-->"+key+",value-->"+m.get(key));
        }
```







### 如何从一个文件档案的尾端新增记录？

答：有两种方法： 

 1)RandomAccessFile fd = new RandomAccessFile(file,"rw"); 

fd.seek(fd.length()); 

然后使用 fd 的method写入 

2)使用FileOutputStream(String name，boolean append) throws IOException这个 constructor





















## 数据库相关：

ORM（对象关系映射）

常见的关系型数据库： Oracle（大型数据库 重量级）   MySql（轻量级数据库）    SQLServer

![](F:\briup\image\Oracle和MYSQL对比图解.png)

### sql语句五大基本类型：

DDl：数据定义语言（表级操作）：create   drop    alter 

DML: 数据操作语言（行级操作）：insert   update   delete

DQL：数据查询语言 ：select

DTL：事务控制语言： commit   rollback   

DCL：权限控制语言：  Grant（授于权限）   Revoke（撤销权限）



### 事务四大特性（ACID）：

原子性（Atomicity）：事物的操作应该是不可分割的  事务同时成功或同时失败 

一致性(Consistency)：成功的事务使系统从一个一致性状态变成另一个 一致性状态，事务执行后,数据库状态与其他业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账户余额之和应该保持不变。

隔离性(Isolation)：事务之间应该是相互隔离的 互不干扰的    每个并发的事务 之间不会相互干扰

持久性(Durability)：一个成功的事务对数据库的影响应该是持久的     即使提交事务后，数据库崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。

### 

### 三大范式（建立关系型数据库的基本规范）：

第一范式：数据库中每一列所代表的属性或意义不可再分了   列名具有原子性

第二范式： 在第一范式的基础上要求 在表中的非主键类 依赖于完整的主键 而不是主键的一部分

第三范式：在第二范式的基础上  要求表中的所有非主键列直接依赖于主键 （禁止依赖传递）即  非主键列1 不可以先依赖于非主键列2   非主键列2在依赖于直接



### 三个名词

sql: 结构化的查询语句，操作oracle数据库的语言  增删改查  
		select * from table_name;

sqlplus: oracle软件自带的可以输入sql，且将sql执行结果显示的终端的一个工具。
注意区分sql语句和sqlplus语句。

pl/sql: 程序化的sql语句，在sql语句的基础上加入一定的逻辑操作，如if for...,使之成为一个sql块，完成一定的功能。

### 四种对象

​	table：表格，由行和列组成，列又称字段，每一行内容为表格的一条完整的数据。
​	view:  视图，一张表或者多张表的部分或者完整的映射，好比表格照镜子，镜子里面的虚像就是view。

除去常见的table和view两种常用对象以外，oracle数据库还支持如下四种对象：
	sequence：	序列  一般用于自动生成主键
	index：		索引，提高数据的访问效率
	synonym：	同义词，方便对象的操作
	program unit：程序单元，pl/sql操作的对象



### 关于SQL语句的小细节

#### SQL语句书写注意事项：

```
SQL语言大小写不敏感；
	SQL可以写在一行或多行；
	关键字不能缩写，也不能分行；
	各子句一般分行写；
	使用缩进提高语句的可读性。
```

#### sql语句和sqlplus命令区别

```
sql是一种语言
ANSI标准
关键字不能缩写
使用语句控制数据库中表的定义和表中的数据

sqlplus是一种环境Oracle的特性之一
关键字可以缩写
命令不能改变数据库中的值
集中运行
```

#### 将查询出来的结果进行排序：

order By xxx 【asc升序】【desc降序】









## JavaWeb：

### Servlet:

#### servlet生命周期：

​        servlet对象在访问服务器时创建    调用init方法初始化对象    之后每次访问不会在创建对象  只会调用service方法  然后层层调用doGet() doPost() 方法（根据访问（请求）方式的不同）  在一般来说服务器关闭时调用destroy() 销毁servlet

#### init初始化方法：

生命周期中的方法一定会被服务器调用，对于初始化方法中提供了两种方法。

两个init方法的作用

         init(ServletConfig)这个有参数的init方法的作用就是Servlet的其中一个重要的生命周期方法。这个方法一定会被tomcat服务器调用。
    
         init():这个无参的init方法的作用就是为了提供给开发者方便去覆盖，覆盖这个方法，可以在此方法编写初始化的逻辑。这个方法才是真的给开发者做初始化逻辑的方法
#### 四种会话跟踪技术：

session：

cookie：

URL重写：<%=response.encodeURL("Ip地址")%>

	URL重写的实现
			String url = response.encodeURL("url");
			这个方法参数就是我们要访问的URL,这个方法会把重写后的URL以字符串的形式返回.
		例如:在一个超链接中,本来要访问的URL是:
				<a href="TestServlet">
		重写后:
		<a href="TestServlet;jsessionid=5480EF9016295A73DC56731A2F123246">
		
		注意:response.encodeURL("url")方法
		如果当前没有使用到session，则直接返回参数url。 
		同时还要注意禁用cookie后是不是已经把之前的cookie给删除了
表单隐藏：

```
 数据保存
    <form action="suc.jsp" method="post">
  标题：<input type="text" name="title" />
  内容：<textarea name="content"></textarea>
  <input type="hidden" name="userName" value="<%=request.getParameter("userName") %>">
  <input type="submit" value="发表">
 </form>
 suc.jsp中获取数据
        Sring name = request.getParameter("userName");
 Sring pwd = request.getParameter("userPwd");
```



#### 在servlet中获取application对象的方法：

1.通过无参初始化方法，直接取得；
2.通过有参初始化方法，必须使用config对象取得。

无参数初始化方法：

ServletContext application=this.getServletContext();

```
public class Applicationextends HttpServlet {  
      
    public void doGet(HttpServletRequest request,HttpServletResponse response)throws IOException,ServletException {  
        this.doPost(request,response);  
    }  
      
    public void doPost(HttpServletRequest request,HttpServletResponse response)throws IOException,ServletException {  
        //取得Application对象  
        ServletContext application=this.getServletContext();  
        //设置Application属性  
        application.setAttribute("name","Magci");  
        //跳转到接收页面  
        response.sendRedirect("application.jsp");  
    }  
} 
```



有参数初始化方法（通过servletConfig对象获得）：

ServletContext application=this.conf.getServletContext();

```
public class Configextends HttpServlet {  
      
    private ServletConfig conf=null;  
      
    public void init(ServletConfig conf) throws ServletException {  
        //实例化config对象  
        this.conf=conf;  
    }  
      
    public void doGet(HttpServletRequest request,HttpServletResponse response)throws IOException,ServletException {  
        this.doPost(request,response);  
    }  
      
    public void doPost(HttpServletRequest request,HttpServletResponse response)throws IOException,ServletException {  
        //通过config对象取得Application对象 
        ServletContext application=this.conf.getServletContext();  
        //设置Application属性  
        application.setAttribute("name","Magci");  
        //跳转到接收页面  
        response.sendRedirect("config.jsp");  
    }  
}
```



### JSP：

一种特殊形式的Servlet   （不应该在JSP中进行过多的逻辑判断）

#### Jsp九大内置对象：

```
page：同一个页面间的信息传递

request：在通一次请求中进行信息传递

session：单次对话间的信息传递（简单理解：浏览器的开启到关闭）

application：Servlet全程的信息传递（服务器的开启到关闭）
      
response：响应   只要用于将JSP容器处理过的对象返回客户端

exception：处理异常的对象

config：配置对象  获取服务器的配置信息   在servlet初始化阶段 容器通过config将某些信息传入servlet   开发者可以通过web.xml为应用程序中的servlet和JSP页面提供初始化参数

pagecontext：上下文环境   获取任何范围的参数 通过它可获取out request   session   application等对象

out：用于在web浏览器中输出信息  并且管理服务器上的输出缓冲区在使用out对象输出数据时可以对缓冲区进行操作 及时处理缓冲区中的残余数据 为其他输出留足够的缓冲空间 并且在使用out输出数据后应及时关闭输出流
```













## SpringFromWork（Spring框架）：



Spring相关概念
	1：轻量级的容器：
	容器：spring容器帮我们管理业务逻辑层，里边有很多业务逻辑对象，有对象就有对象的生命周期的管理（创建，销毁）。
	轻量级：容器给予的业务逻辑对象多少种服务？spring给用户提供的服务完全有用户自己决定，spring想用什么服务自己开启使用。
	但是重量级的都是只要你用就把所有的服务都给你，不能自己定制。spring容器从来不能独立运行，一定借助于其他容器启动，
	或者借助web容器启动，或者ejb容器启动。		
	特点：
	应用模块之间耦合度小，组件都是可重用的，都是各自打包的

### IOC：

控制反转  依赖注入

 一种说法：对象之间的依赖关系，由容器在运行时依据配置文件动态的建立
       另一种说法：对象的控制器转移了，转到外部容器了，避免了代码的纠缠，代码更容易被维护，模板之间的耦合性降低，容易测试 

进行对象解耦   代码间的耦合性降低   代码的复用性变高  代码的可维护性变高  可扩展性变强

**传统对象关系图**：

![](F:\briup\image\对象的耦合关系图.png)





**使用IOC理论之后的对象间的耦合关系图：**

![](F:\briup\image\经过IOC.png处理的对象耦合关系.png)

#### 配置文件：

```xml
Spring通过读取配置文件中的数据来对应用中各个对象进行实例化,配置以及组装,通常使用XML文件来作为配置文件。
   XML基本结构如下:
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
   		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   		 xsi:schemaLocation="http://www.springframework.org/schema/beans
        	http://www.springframework.org/schema/beans/spring-beans.xsd">
	   
	</beans>
```

#### IOC注入：

##### 1.set注入  

 必须依靠set方法   类中必须提供set方法

   可以注入的内容有:
      A、基本类型（8中基本类型+字符串）的装配       方式: 配置元素<value/>

```xml
	<bean id="helloBean" class="ioc.HelloBean">
		<property name="name">
			<value>tom</value>
		</property>
			<property name="age" value="20">
		</property>
	</bean>
```

​      B、对象类型的装配 

```xml
   （1）、<ref bean=" "/>  
   （2）、使用property的ref属性引用
   
   	配置other.xml文件
	<bean id="otherBean" class="ioc.OtherBean">
		<property name="str1">
			<value>string1</value>
		</property>
	</bean>
   
   	<bean id="someBean" class="ioc.SomeBean">
		<property name="ob">
			<ref bean="otherBean" />
		</property>
	</bean>
```
​      C、集合的装配:

```xml
<bean id="someBean" class="ioc.SomeBean">
		<property name="listProperty">
			 <list>
			    <value>list1</value>
			    <value>list1</value>
			    <value>list3</value>
			    <ref bean="otherBean"/>
			 </list>
		</property>
		<property name="setProperty">
			 <set>
			    <value>set1</value>
			    <value>set1</value>
			    <value>set3</value>
			    <ref bean="otherBean"/>
			 </set>
		</property>
		<property name="mapProperty">
			 <map>
			    <entry key="key1">
				  <value>value1</value>
			    </entry>
			    <entry key="key2">
				  <value>value2</value>
			    </entry>
			    <entry key ="key3" value-ref="otherBean"/>
			 </map>
		</property>
		<property name="property">
		     <props>
			  <prop key="key1">prop1</prop>
			  <prop key="key2">prop2</prop>
			  <prop key="key3">prop3</prop>
		     </props>
		</property>
	</bean>
```

##### 2.构造器注入:

```xml
方式: 配置<constructor-arg>元素
在Bean中不用写set方法，但是要有相应的构造器

构造器注入有俩种形式 一个是根据参数类型 一个是根据参数位置的下标
<constructor-arg type="int" value="">
<constructor-arg  index="0" value="">

	例如:
	<bean name="student" class="com.briup.bean.Student">
	    	<constructor-arg type="int" value="25">
	    	</constructor-arg>
	    	
	    	<constructor-arg type="java.lang.String" value="tom">
	    	</constructor-arg>
	    	
	    	<constructor-arg type="long" value="100">
	    	</constructor-arg>
    	 
	</bean>

	或者:
	<bean name="student" class="com.briup.bean.Student">
		 <constructor-arg index="2">
			<value>30</value>
		 </constructor-arg>
		 
		 <constructor-arg index="0">
			<value>200</value>
		 </constructor-arg>
		 
		 <constructor-arg index="1">
			<value>lily</value>
		 </constructor-arg>
	</bean>
```






##### 3.自动注入：

   注意:自动装配只对[对象类型]起作用，对基本类型不起作用.



     第一种情况:
          在beans标签中配置装载方式：default-autowire="byName"
          default-autowire="byName"
        		在根元素beans中加入这个属性,那么下面所有的bean都会
        		使用byName的方式进行自动注入,如果在下面的某一个bean
        		里面想使用其他的方式进行注入,可以用autowire=""属性进行
        		说明,或者某一个bean不想使用任何自动注入就使用autowire="no"
        		
    第二种情况:
      在bean标签中指定配置方式
      autowire="byName":
    		spring容器会到当前的类中找property的名字,然后
    		再根据这个名字去spring容器中找有没有和这个property
    		名字相同的对象,有的话,就把这个对象当做参数放到
    		setXxxx这个方法里面注入进来.
    		注意:了解property指的类中的什么东西。
    
      autowire="byType":
    		spring容器会根据当前类中的set方法里面参数的类型,
    		去容器中找相匹配的对象,如果没找到就算了,如果找到
    		一个就注入进来,如果找到多个,那么就会报错了.
    
      autoWrite="constructor" 
    	根据构造器的参数类型去匹配
#### Bean的生命周期：

> ​	**单例管理的对象:**
> ​	1.默认情况下,spring在读取xml文件的时候,就会创建对象。
> ​	2.在创建的对象的时候(先调用构造器),会去调用init-method=".."
> ​	属性值中所指定的方法。
> ​	3.对象在被销毁的时候,会调用destroy-method="..."属性值中
> ​	所指定的方法.(例如调用container.destroy()方法的时候)
> ​	4.lazy-init="true",可以让这个对象在第一次被访问的时候创建（延迟加载）
> ​	
> ​	**非单例管理的对象:**
> ​	1.spring读取xml文件的时候,不会创建对象.
> ​	2.在每一次访问这个对象的时候,spring容器都会创建这个对象,并且
> ​	调用init-method=".."属性值中所指定的方法.
> ​	3.对象销毁的时候,spring容器不会帮我们调用任何方法,
> ​	因为是非单例,这个类型的对象有很多个,spring容器一旦把
> ​	这个对象交给你之后,就不再管理这个对象了. 

#### 创建bean实例的方式

   1) xml文件中有bean的配置,而且这个bean所对应的java类中存在一个无参构造器，那么这个时候spring容器就可以使用反射调用
       无参构造器来创建实例了

   2) 通过工厂类获得实例(工厂类实现了接口FactoryBean<?>)
      注意spring中的PropertyPlaceholderConfigurer类的使用,在htmlsingle中直接搜索类名即可
      例如:
      工厂类实现指定接口并且实现接口中的三个抽象方法:

```java
  //泛型为工厂需要生产的对象类型
  public class ConnectionFactory implements FactoryBean<Connection>{
	private String driver;
	private String url;
	private String username;
	private String password;

	@Override
	public Connection getObject() throws Exception {
		Class.forName(driver);
		Connection conn = 
			DriverManager.getConnection(url,username,password);
		return conn;
	}

	@Override
	public boolean isSingleton() {
		// TODO Auto-generated method stub
		return false;
	}
	
	@Override
	public Class<Connection> getObjectType() {
		// TODO Auto-generated method stub
		return Connection.class;
	}
	set/get
	....
  }
```


​      
​      
​            xml文件:

​        	

```xml
 <!-- 
    因为这个类是一个工厂类,所以我们用名字conn在容器中拿对象的时候,拿到并不是这个工厂类对象,而是这个工厂类对象调用完工厂方法后所返回的对象.
          -->
          <bean name="conn" class="com.briup.ioc.factory.ConnectionFactory">
        	<property name="driver">
        		<value>${driver}</value>
        	</property>
    <property name="url">
    		<value>${url}</value>
    	</property>
    	
    	<property name="username">
    		<value>${username}</value>
    	</property>
    	
    	<property name="password">
    		<value>${password}</value>
    	</property>
      </bean>
```
   3) 通过实例工厂获得实例(不需要实现或者继承任何接口或者父类)

```java
例如:一个普通的工程类
      public class ConnectionFactory{
		private String driver;
		private String url;
		private String username;
		private String password;
		
		public Object getConnection() throws Exception {
			Class.forName(driver);
			Connection conn = 
				DriverManager.getConnection(url,username,password);
			return conn;
		}
		get/set
		....
      }

      
```

   xml文件:


```xml
		 <bean name="factory" class="com.briup.ioc.instanceFactory.ConnectionFactory">
		<property name="driver">
			<value>${driver}</value>
		</property>
		
	<property name="url">
		<value>${url}</value>
	</property>
	
	<property name="username">
		<value>${username}</value>
	</property>
	
	<property name="password">
		<value>${password}</value>
	</property>
 </bean>
    
 <!-- 
	将来通过这个conn来拿对象,拿到的是名字为factory的工厂类调用完
	名字为getConnection方法之后所返回的对象。
 -->
 <bean name="conn" factory-bean="factory" factory-method="getConnection"></bean>
 
 <!-- 读取properties文件 -->
     <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="location">
		<value>classpath:oracle.properties</value>
	</property>
 </bean>

```
```java
 //main:
	String path = "com/briup/ioc/instanceFactory/instanceFactory.xml";
	ApplicationContext container = 
		new ClassPathXmlApplicationContext(path);
	Connection conn = (Connection) container.getBean("conn");
	System.out.println(conn);
	
```

4) 通过静态工厂获得实例

```java
 例如:含义静态方法的工厂类
      public class ConnectionFactory{
		private static String driver = "oracle.jdbc.driver.OracleDriver";
		private static String url = "jdbc:oracle:thin:@172.16.157.130:1521:XE";
		private static String username = "briup";
		private static String password = "briup";
		
		public static Object getConnection() throws Exception {
			Class.forName(driver);
			Connection conn = 
				DriverManager.getConnection(url,username,password);
			return conn;
		}
      }

  
      

```



```xml

xml文件:
  <!-- 这样配置一定要求getConnection方法是静态方法 -->
  <bean name="conn" class="com.briup.ioc.staticFactory.ConnectionFactory" factory-method="getConnection"></bean>
 <!--<bean name="conn" factory-bean="factory" factory-method="getConnection"></bean> -->
```
```java
  main:
	String path = "com/briup/ioc/staticFactory/staticFactory.xml";
	ApplicationContext container = 
		new ClassPathXmlApplicationContext(path);
	Connection conn = (Connection) container.getBean("conn");
	System.out.println(conn);
```


#### BexanFactory和FactoryBean

 FactoryBean是Spring中的一个普通借口   用于通过工厂类创建产品类 

可以简化XML配置和隐藏细节   返回不同Bean的实例    Factory管理的类不能再配置到XML文件中   否则会报异常

FactoryBean接口内有三个方法

```
//返回产品类对象
T getObject() throws Exception;
//返回产品类的Class对象
Class<?> getObjectType();
//返回值为Boolean类型    决定产品类的对象是否为单例的
boolean isSingleton();
```

BeanFactory是IOC容器的核心接口     用于管理Bean    

作用是   实例化  定位   配置Spring应用程序中对象以及建立对象间的依赖关系

Springp容器提供了很多种实现，如：XmlBeanFactory、ApplicationContext等





#### ioc中的annotation配置

	<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	    http://www.springframework.org/schema/beans/spring-beans.xsd
	    http://www.springframework.org/schema/context
	    http://www.springframework.org/schema/context/spring-context.xsd">

#####   @Autowired

  1 @Autowired默认按照byType匹配的方式进行注入,如果没有一个bean的类型是      	匹配的则会抛异常,如果有多个bean的类型都匹配成功了,那么再按byName方	式进行选择
  2 @Autowired注解可以写在成员变量、setter方法、构造器函数上面
  3 @Autowired如果最终匹配不成功(注意一定是一个都没有找到的情况)则会抛出异常,但是如果设置为 @Autowired(required=false),则最终匹配不成功没有不会抛出异常。
  4 @Autowired可以结合 @Qualifier("beanName")来使用,则可以达到byName的效果
  5 @Autowired使用后需要在xml文件加入以下配置才能生效:
      <context:annotation-config/>   

#####   @Resource

  1 @Resource的作用和 @Autowired差不多,只不过 @Resource是默认先用byName,如果找不到合适的就再用byType来注入
  2 @Resource有俩个属性,name和type,使用name属性则表示要byName匹配,使用type属性则表示要byType匹配
  3 @Resource使用后需要在xml文件加入以下配置才能生效:
      <context:annotation-config/>   

#####   @PostConstruct 和 @PreDestroy

  1 标注了 @PostConstruct 注释的方法将在类实例化后调用。
  2 标注了 @PreDestroy 的方法将在类销毁之前调用。

#####   @Component

  1 @Component注解可以直接定义bean，而无需在xml定义。但是若两种定义同时存在，xml中的定义会覆盖类中注解的
        Bean定义。
  2 @Component注解直接写在类上面即可
  3 @Component有一个可选的参数，用于指定 bean 的名称: @Component("boss")
  4 @Component容易不指定参数，则 bean 的名称为当前类的类名小写
  5 @Component使用之后需要在xml文件配置一个标签: <context:component-scan/>
  6 <context:component-scan base-package="com.briup.ioc.annotation" /> 可以表示spring需要检查哪个包下的java类,看它们是否使用了 @Component注解
  7 @Component定义的bean默认情况下都是单例模式的,如果要让这个bean变为非单例,可以再结合这个 @Scope 注解来达到目标 @Scope("prototype")

  @Component是Spring中bean组件的通用形式, @Repository @Service @Controller 则是 
  @Component的细化,用来表示更具体的用例，分别对应了持久化层、服务层和表现层。
  但是至少到现在为止这个四种注解的实质区别很小(甚至几乎没有),都是把当前类注册为spring容器中的一个bean

#####   注意:

  component-scan标签默认情况下自动扫描指定路径下的包（含所有子包），将带有 @Component @Repository 
  @Service @Controller标签的类自动注册到spring容器。对标记了 Spring中的 @Required @Autowired 
  @PostConstruct @PreDestroy @Resource @WebServiceRef @EJB   @PersistenceContext @PersistenceUnit
  等注解的类进行对应的操作使注解生效（包含了annotation-config标签的作用）。

### AOP：

#### 代理模式:

    代理模式是常用的Java 设计模式，它的特征是代理类与委托类有同样的接口，
    代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。
    代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，
    代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。
   `注意:`
      委托类对象就是我们后面说到的 目标对象(需要【被】代理的对象)
      代理类对象就是我们后面说到的 代理对象(目标对象就是需要这个对象做为代理)
   按照代理类的创建时期，代理类可分为两种。
      静态代理类：
	    由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
      动态代理类：在程序运行时，运用反射机制动态创建而成



##### 静态代理

   例如:
	接口：HelloService
	委托类：HelloServiceImpl
	代理类：HelloServiceProxy

```java
public interface HelloService{
  public String echo(String msg);
  public Date getTime();
}

public class HelloServiceImpl implements HelloService{
  public String echo(String msg){
    return "echo:"+msg;
  }
  public Date getTime(){
   return new Date();
  }
}

public class HelloServiceProxy implements HelloService{
  private HelloService helloService; //表示被代理的HelloService 实例
  public HelloServiceProxy(HelloService helloService){
    this.helloService=helloService;
  }
  public void setHelloServiceProxy(HelloService helloService){
     this.helloService=helloService;
  }
  public String echo(String msg){
    System.out.println("before calling echo()"); //目标方法调前处理
    //调用委托类对象的方法(也就是目标对象方法/被代理对象方法)
    //这个方法才是我们真正要执行的方法
    String result=helloService.echo(msg); 
    System.out.println("after calling echo()"); //目标方法调用后处理
    return result;
  }
  public Date getTime(){
    System.out.println("before calling getTime()"); //目标方法调前处理

    //调用委托类对象的方法(也就是目标对象方法/被代理对象方法)
    //这个方法才是我们真正要执行的方法
    Date date=helloService.getTime();

    System.out.println("after calling getTime()"); //目标方法调用后处理
    return date;
   }
}

main:
   HelloService helloService=new HelloServiceImpl();
   HelloService helloServiceProxy=new HelloServiceProxy(helloService);
   System.out.println(helloServiceProxy.echo("hello"));
```
**特点：**代理类和委托类实现同一个接口   在代理类中添加一个接口类对象    同时添加一个单参构造方法  将接口类对象初始化    在测试代码中先创建委托类对象 之后将委托类对象作为代理类对象的参数通过构造方法传给代理类对象 在调用代理类中的同名方法  即静态代理          

**缺点：**代码复用性偏差     不灵活

##### 动态代理：

   与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写
   它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型
   的动态代理类。java.lang.reflect 包下面的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。

**代码示例：**

```java
接口:
   public interface IStudentService {
	
	void save(Student s);
	
	void delete(long id);
	
	Student find(long id);
	
   }

日志类:
   public class StudentLogger {
	
	public void log(String msg){
		System.out.println("log: "+msg);
	}
	
   }
实现类
   public class StudentServiceImpl implements IStudentService {
	public void delete(long id) {
		// 记录日志
		System.out.println("student is deleted...");
	}

	public Student find(long id) {
		// 记录日志
		System.out.println("student is found...");
		return null;
	}

	public void save(Student s) {
		// 记录日志
		System.out.println("student is saved...");
	}
   }
   
   //InvocationHandler接口的实现类,java的动态代理中需要使用
   public class MyHandler implements InvocationHandler {
	//目标对象
	private Object target; 
	private StudentLogger logger = new StudentLogger();

	public MyHandler() {
	}

	public MyHandler(Object target) {
		this.target = target;
	}

	// 参数1 将来所产生的代理对象 Proxy4$
	// 参数2 将来需要调用到的目标对象里面真正的那个方法的镜像
	// 参数3 将来调用方法的时候所传的参数
	public Object invoke(Object proxy, Method m, Object[] args)
			throws Throwable {
		// 获得将来所调用方法的名字
		String methodName = m.getName();
		// 用日志记录输出一下
		logger.log(methodName + " is invoked...");
		// 用反射的方式去调用将来需要真正调用的方法.
		Object o = m.invoke(target, args);

		return o;
	}
	get/set
	....
   }

   main:
	//目标对象
	IStudentService service = new StudentServiceImpl();
	//service是我们的目标对象。
	//我们要给目标对象产生代理对象。
	//目标对象service只能单独执行delete方法。
	//但是我们需要的是:先执行log日志方法再执行delete方法。
	//目标对象service做不到这个要求,所以我们要给目标对象service
	//生成一个代理对象去完成这俩个操作.


	//怎么给目标对象生成代理对象:
	//JDK动态代理的方式

	//获得目标对象的Class对象
	Class c = service.getClass();
	//获得目标对象的类加载器对象
	ClassLoader classLoader = c.getClassLoader();

	//获得目标对象所实现的所有接口
	Class[] interfaces = c.getInterfaces();

	//获得一个InvocationHandler接口的实现类对象,并把目标对象传进去
	InvocationHandler h = 
			new MyHandler(service);

	//参数1 目标对象的类加载器对象
	//参数2 目标对象所实现的所有接口. Class类型数组
	//参数3 InvocationHandler接口的实现类对象
	IStudentService proxy = 
		(IStudentService)Proxy.newProxyInstance
		(classLoader, interfaces, h);
	//这里的proxy是一个实现了IStudentService接口动态生成的代理类的对象
	proxy.delete();
```



**注意**：

代理类需要实现 InvocationHandler接口  重写invoke方法     

动态代理不需要代理类和委托类实现同一个接口      但是委托类（目标对象）必须实现接口

代理类（InvocationHandler接口的实现类对象）中的invoke方法的 第一个参数为  委托类   第二个参数为 真正需要调用的目标对象的真正方法的镜像   第三个参数为  真正方法的参数 

proxy.newProxyInstance() 中也需要传入三个参数   第一个参数为：目标对象的类加载器   第二个参数为：目标对象的所有实现了的接口的.Class类型的数组   第三个参数为 代理对象 （InvocationHandler接口的实现类对象）   





##### CGLib代理：

   JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。
   CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为目标对象创建一个子类对象，并在子类对象中拦截
   所有父类方法的调用，然后在方法调用前后调用后都可以加入自己想要执行的代码。JDK动态代理与CGLib动态代理都是
   Spring AOP的采用的代理方式。

**示例代码**：

```java
 /**该类实现了创建一个类的子类的方法(cglib给一个类生成代理对象的方式)
   getProxy(SuperClass.class)方法通过参数即父类的class对象，创建出它的一个子类对象,也就是cglib方式的代理对象
   intercept()方法拦截所有目标类方法的调用，
   obj表示将来生成的代理对象，
   method为目标类中方法的反射对象，args为方法的动态入参，
   mproxy为代理类(子类)中方法的反射对象。
   mproxy.invokeSuper(obj, args)通过代理类调用目标对象(父类)中的方法。*/
	
   public class CglibProxy implements MethodInterceptor{

	 public Object getProxy(Class clazz){
	     Enhancer enhancer = new Enhancer();
	     //设置谁是父类
	     enhancer.setSuperclass(clazz);
	     enhancer.setCallback(this);
	     //通过字节码技术动态创建子类实例
	     return enhancer.create();
	 }

	 //实现MethodInterceptor接口方法
	 public Object intercept(Object obj, Method method, Object[] args,
	     MethodProxy mproxy) throws Throwable {
	     System.out.println("前置代理");
	     //通过代理类调用父类中的方法
	     Object result = mproxy.invokeSuper(obj, args);
	     System.out.println("后置代理");
	     return result;
	 }
   }


   main:
      CglibProxy proxy = new CglibProxy();
      //通过生成子类的方式创建代理类
      SayHello proxyImp = (SayHello)proxy.getProxy(SayHello.class);
      proxyImp.say();

   输出结果：
   前置代理
   hello everyone
   后置代理
```

**注意：**在cglib方式中,目标对象作为父类,代理对象作为目标对象动态生成的子类对象

#### AOP的代理方式

Spring实现AOP(Aspect Oriented Programming)是依赖JDK动态代理和CGLIB代理(不同情况spring会自己选择一种方式)。
    JDK动态代理和CGLIB代理的对比:
    JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的
                                代理。
    CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是
                           高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的。

    所以spring会有以下俩种选择动态代理实现方式的情况:
     *如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP
     *如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间自动选择;
#### AOP的基本概念：

| 名字      | 意义                                                         |
| --------- | ------------------------------------------------------------ |
| AOP       | 面向切面编程                                                 |
| aspect    | 切面/切面类                                                  |
| joinPoint | 在spring的aop中只有 类中的方法 可以做连接点,每一个方法都可以是一个连接点. |
| pointCut  | 切入点 ：一组连接点的集合                                    |
| advice    | 通知/拦截器：用来控制切面类将来到底是织入到切入点的前面、后面或者是抛异常的时候。 |
| adivsor   | 增强器：		用来筛选类中的哪些方法是我们的连接点(哪些方法需要被拦截). |
| target    | 目标对象                                                     |
| proxy     | 代理对象                                                     |
| wave      | 织入                                                         |


**通知相关：**

| 名称                                      | 含义                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| 前置通知（Before advice）：               | 在某连接点（join point）之前执行的通知                       |
| 返回后通知（After returning advice）：    | 在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。 |
| 抛出异常后通知（After throwing advice）： | 在方法抛出异常退出时执行的通知。                             |
| 后通知（After (finally) advice）：        | 当某连接点退出的时候执行的通知                               |
| 环绕通知（Around Advice）：               | 包围一个连接点（join point）的通知，例如事务的处理,就需要这样的通知,因为事务需要在方法前开启,
在方法后提交 |



### SpringMVC:

**注入的是三个不同的类型(Model model1, Map model2, ModelMap model3),但三者是同一个对象**

### 前置知识点：

#### MVC框架:

> MVC虽然是三部分但是和三层架构没有直接的关系
>

**MVC分为三部分，分别是:**

​      ●Model：模型，表示应用程序核心，比如数据记录列表

​      ●View：显示，对数据进行显示

​      ●Controller：控制器，对数据库的各种操作进行控制

**MVC架构图：**

![](F:\briup\image\MVC架构图.jpg)

#### Spring的工作原理图：

![](F:\briup\image\SpringMVC运行原理图.png)

**图解：**    

- HandleMapping将请求映射到controller类上（类级别）
- HandleAdaper将请求指定到对应的方法上（方法级别）

？？ModelAndView   如何使用  到底是什么  在返回值为String 且将数据存放在Session中时ModelAndView是否还起作用

  **在SpringMVC中Map  Model ModelMap 本质是同一个对象**



## OOAD 

 Java中的设计模式

### 设计模式基本原则：

- 单一职责原则
- 开闭原则（对扩展开放 对修改关闭）
- 依赖倒置原则
  1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象。
  2. 抽象不应该依赖细节。
  3. 细节应该依赖抽象。
- 里氏代换原则（使用父类的地方都可以使用子类替换）
- 接口隔离原则（对接口进行细分  如果一个类实现接口和有无用的方法 那接口应该被拆分   *`接口要尽量小   接口应该高内聚`*）
- 迪米特原则 （最少知道原则  ）：一个类应该对另一个类有尽量少的了解

### 常见的设计模式：

**单例模式：**构造私有化    提供公共静态方法获取对象  

- 饿汉模式：

```java
class xxx{
    private xxx(){}
    static xxx x=new xxx();
    public static xxx getxxx(){
        return x;
    }
}
```

- ​    懒汉模式

```java
class xxx{
    private xxx(){}
    static xxx x = null;
    public static xxx getxxx(){
        if(x!=null) return x;
        return new xxx();
    }
}
```

> 单例模式的优缺点：
>
> 优点： 
>
> -   减少对内存的开销    尤其是频繁的创建和销毁对象
> - 避免对内存过多的占用
>
> 缺点：
>
> - 没有抽象层   不能继承扩展很难 
> - 违背了单一职责原则  一个类只重视内部关系  忽略了外部关系
> - 不适用于变化对象
> - 滥用单例会出现一些负面问题，如为节省资源将数据库连接池对象设计为单例，可能会导致共享连接池对象对程序过多而出现连接池溢出。如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这样将导致对象状态丢失。
>
> 

**工厂模式：**

- 简单工厂模式：
- 工厂方法模式：
- 抽象工厂模式：

抽象工厂和工厂方法：

工厂方法：一个抽象产品类  对应多个具体产品类   一个抽象工厂类对应多个子工厂类  每个子工厂只能生产一种产品

抽象工厂：多个抽象产品类   一个抽象工厂类  在工厂类接口中定义多个方法  可以生产出多种产品  （一个产品组）









































































































