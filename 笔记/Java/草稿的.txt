第三章：表达式和流程控制
目标：
	1.成员变量和局部变量
	2.成员变量的初始化
	3.发现并修复代码中的Bug
	4.Java中的操作符
	5.基本数据类型的求值
	6.布尔表达式/逻辑表达式
	7.流程控制语句

2，成员变量的初始化
class Student
{
              String name；
	      int age；
      
      //无参构造器
	      Student（）{
                             name="Keving";
			     age=26;
	      }
	      //方法的形式参数
	      //在定义方法时  方法名后面的括号中的参数
	      //方法中的形参就相当于在该方法中定义的局部变量
           Student(String name,int age){
                           this.name=name;
			   this.age=age；
                  } 
		  有参构造器
		  类名（参数1，参数2，。。。。。，参数N）{}
直接进行赋值
     class Student{
                    int  age=10；
		    }
通过构造器赋值 
   class Student{
      int age；
      Student（）{
                 this.age=10；
		 }
		 student(int age){
                   this.age=age;
		   }
      }
      Student stu=new student(20);
++
- - 
     前置:变量先自增或自减在参与执行
     后置：变量先执行再自增或自减
                int num=10；
		num++;
		num=10;
		++num;
&&：短路与。

 //"kevin"  17实际参数

	      Student stu = new Student（"kevin",17）；
}
构造器赋值：通过构造器传递参数的形式，将某个值（实参）传递给成员变量。
      构造器;又称构造方法，指的是以类名为方法名的并且没用返回值的方法。


4.Java中的操作符（在补码进行操作）：
	1.Assignment Operators，赋值操作符
		=：直接赋值操作符。
			int num=10;

		+=：先加再赋值；
			int num=10;
			num+=10; -> num=num+10; -> num=20;
		-=：先减再赋值；
		*=：先乘再赋值；
		/=：先除再赋值；
			int num=10;
			num/=2;		num=num/2;		num=5;
		%=：先取余再赋值；
			int num=10;
			num%=2;		num=num%2;		num=0;

		<<=：有符号左移，针对于二进制数的补码，然后向左移动相应的位数。
			int num=10;
			num<<=2;	num=num<<2;		num=40;

		0000 0000 0000 0000 0000 0000 0000 1010   10
	        0000 0000 0000 0000 0000 0000 0000 1010     <-
		0000 0000 0000 0000 0000 0000 0010 1000	  40

			int num=10;
			num<<=3;	num=num<<3;		num=?

		0000 0000 0000 0000 0000 0000 0000 1010   10
	 0000 0000 0000 0000 0000 0000 0000 1010     <-
		0 0000 0000 0000 0000 0000 0000 1010000	  80
		
		int num=-10;
		num<<=2;	num=-10*2^2=-40

		1000 0000 0000 0000 0000 0000 0000 1010  原码
	  1111 1111 1111 1111 1111 1111 1111 0110    补码
	    11 1111 1111 1111 1111 1111 1111 011000  补码
		10 0000 0000 0000 0000 0000 0000 101000  原码

左移操作：num<<=N;	num=num*2^N;

		>>=：有符号右移，针对于二进制数的补码，然后向右移动相应的位数。

		int num=10;
		num>>=2;	num=num>>2;		num=2;
	
		0000 0000 0000 0000 0000 0000 0000 1010     10
		  0000 0000 0000 0000 0000 0000 0000 1010   ->
		000000 0000 0000 0000 0000 0000 0000 10     2

		num>>=3;	num=num>>3;		num=1;
	
		0000 0000 0000 0000 0000 0000 0000 1010     10
		   0000 0000 0000 0000 0000 0000 0000 1010  ->
		0000000 0000 0000 0000 0000 0000 0000 1     1

		int num=-10;
		num>>=2;	num=-3

		1000 0000 0000 0000 0000 0000 0000 1010    原码
		  1111 1111 1111 1111 1111 1111 1111 0110  补码
		111111 1111 1111 1111 1111 1111 1111 01    补码
		100000 0000 0000 0000 0000 0000 0000 11	   原码

右移操作：num>>=N;	num=num/2^N;

		>>>=：无符号右移：
			正数：和>>=没有区别。
			负数：先将负数转化成对应的补码，然后右移，然后前面补0，
			然后转化成原码，再转化成10进制。
		int num=-10;
		num>>>=2;	num=?
		
		1000 0000 0000 0000 0000 0000 0000 1010    原码
		  1111 1111 1111 1111 1111 1111 1111 0110  补码
		001111 1111 1111 1111 1111 1111 1111 01    补码
		001111 1111 1111 1111 1111 1111 1111 01    原码

		负数经过无符号右移之后会变成一个很大的数。

		人为进行计算：
		正数：原码（补码）=》移位操作=》补码（原码）=》十进制
		负数：原码=》反码=》补码=》移位操作=》补码=》反码=》原码=》十进制

		&=：按位与操作符：
			1&1=1;	1&0=0;	0&0=0;
		
			int num=10;
			num&=5;	 ->	 num=num&5;		->	num=0

			0000 0000 0000 0000 0000 0000 0000 1010
			0000 0000 0000 0000 0000 0000 0000 0101
			---------------------------------------
			0000 0000 0000 0000 0000 0000 0000 0000	 = 0

			int num=-10;
			num&=5;		num=num&5;		num=4

			1111 1111 1111 1111 1111 1111 1111 0110
			0000 0000 0000 0000 0000 0000 0000 0101
			---------------------------------------
			0000 0000 0000 0000 0000 0000 0000 0100	 = 4

			int num=-10;
			num&=-5;	num=num&-5;		num=?

			1111 1111 1111 1111 1111 1111 1111 0110
			1111 1111 1111 1111 1111 1111 1111 1011
			---------------------------------------
			1111 1111 1111 1111 1111 1111 1111 0010
			1000 0000 0000 0000 0000 0000 0000 1110  = -14

		|=：按位或（析取 1是0否）操作：
			1|1=1;	1|0=1;	0|0=0;

		正数|正数：
		int num=10;
		num|=5;		num=num|5;		num=15

		0000 0000 0000 0000 0000 0000 0000 1010
		0000 0000 0000 0000 0000 0000 0000 0101
		---------------------------------------
		0000 0000 0000 0000 0000 0000 0000 1111  = 15

		负数|负数：
		int num=-10;
		num|=-5;		num=num|-5;		num=-1

		1111 1111 1111 1111 1111 1111 1111 0110（-10的二进制补码）
		1111 1111 1111 1111 1111 1111 1111 1011（-5的二进制补码）
		---------------------------------------
		1111 1111 1111 1111 1111 1111 1111 1111
		1000 0000 0000 0000 0000 0000 0000 0001  = -1

		正数|负数：
		int num=-10;
		num|=5;		num=num|5;		num=-9

		1111 1111 1111 1111 1111 1111 1111 0110
		0000 0000 0000 0000 0000 0000 0000 0101
		---------------------------------------
		1111 1111 1111 1111 1111 1111 1111 0111
		1000 0000 0000 0000 0000 0000 0000 1001  = -9

		^=：按位异或，相同为0，不同为1；
		
		int num=10;
		num^=5;		num=num^5;		num=15

		0000 0000 0000 0000 0000 0000 0000 1010（10的原码（补码）10为正数）
		0000 0000 0000 0000 0000 0000 0000 0101
		---------------------------------------
		0000 0000 0000 0000 0000 0000 0000 1111	 = 15

		正数|正数=正数；
		正数|负数=负数；
		负数|负数=正数；

~：取反操作符；

		int num=10;
		num=~num;		num=-11

		0000 0000 0000 0000 0000 0000 0000 1010
		1111 1111 1111 1111 1111 1111 1111 0101
		1000 0000 0000 0000 0000 0000 0000 1011  =  -11

		int num=9;
		num=~num;		num=-10

		0000 0000 0000 0000 0000 0000 0000 1001
		1111 1111 1111 1111 1111 1111 1111 0110
		1000 0000 0000 0000 0000 0000 0000 1010  =  -10

		int num=-10
		num=~num;		num=9
		1111 1111 1111 1111 1111 1111 1111 0110
		0000 0000 0000 0000 0000 0000 0000 1001  =  9

原数值加1取相反数。

	2.Comparison Operators：比较操作符，结果是boolean类型。
		> ：大于。
			1>2：false
			2>1：true

		>=：大于等于。
			2>=2：true
			2>=1：true
			2>=3：false

		< ：小于。
		<=：小于等于。
		==：用来判断该符号左右的两个数据的内存地址是否相同。
			int a=1;
			int b=1;
			a==b：true

			1==1：true
			1==2：false

		!=：用来判断该符号左右的两个数据的内存地址是否不同。
			1!=1：false
			1!=2：true

		instanceof：关键字。结果true或者false。
			对象 instanceof	类
			判断左边的对象是否右边的类的对象。

		class Student{}

		class Teacher{}

		Student stu=new Student();

		Teacher tea=new Teacher();

		stu instanceof Student      --->	true
		stu instanceof Teacher		--->    false

	3.算术操作符：
		+：
			1.用于数学计算：
				int num=1+1;

				int a=10;
				int b=a+10;

			2.用于字符串拼接：
				String str1="Hello";
				String str2="World";
				String str3=str1+str2+"Briup"+6+7;
					   str3="HelloWorldBriup67";

				String str4="Kevin";
				syso(100+str4);		======> 100Kevin
				syso(100+200+str4);	======> 300Kevin//当数学算式在字符串前是进行计算        
				syso(100+200+str4+100);	======> 300Kevin100//字符串在前时后面的数据都作为字符串进行输出。

		-：数学运算。
			int x=100-12;
			
			int a=10;
			int b=a-1;

		*：数学运算。
		/：数学运算。取商。
		%：数学运算。取余。

	4.逻辑操作符：    (ture和false代表判断语句)
 		&&：逻辑按位与
	    true&&true=true
            true&&false=false
            false&&fasle=false
            
		||：逻辑按位或
            true||true=true
            true||false=true
            false||fasle=false

	5.条件运算符：?:，三目运算符。

		!true	单目运算符
		1+1		双目运算符

		条件表达式(逻辑表达式)?代码1:代码2;     三目运算符

		当问号前面的条件表达式为true的时候执3代码1，为false的时候执行代码2；可以被if...else...语句代替。

		int num=10;
		num>=10?num=9:num=00;
		对常量1到常量N和Key进行匹配，如果匹配那个case就执行那个case中的代码




		面向对象：不关注具体过程，只关注对象（数据）；
		面向过程： 关注具体的动作。
		          万物皆对象：
			   对象是唯一的
			   对象具有属性和行为
			   对象具有状态。
			  方法：某个对象的能够改变给对象的状态的行为；
                           方法的定义：
			                  [权限修饰符][static]返回值类型 方法名（形参一【形参N】）{
					      方法体；
                                              [return 值]
					  }
					  权限修饰符：public（公共的，使用该修饰符修饰的可以在任意一个类调用）
					                           prevate（私有的 ，只能在该方法所属的类中调用）
					 【static】：表示该方法只属于类，由类名.方法名来直接调用，不需要通过对象来调用，但可以使用对象调用。
				返回值类型：方法调用者在调用该方法结束后，是否需要获取该方法所处理的结果数据（返回值）。
				       有返回值：视具体情况而定，基本类型的引用类型。
				       无返回值： void 
                      方法名：遵循标识符的命名规则。
		                  规则：
				           不能以数字开头：
					   不能包含特殊字符；
					   只能以字母，_,$开头；
					   中间可以包含数字；
				  规范：
				          见名知意；
					  驼峰命名法；
				   参数：
				   形式参数;在定义方法的时候，给方法所制定的参数称为形参
				   实际参数：在调用方法的时候，给该方法所传递的参数称为实参；
				  方法体：  该方法体的具体执行过程

                                       返回值：方法执行的结果数据：当方法执行完成后，需要返回数据给使用者，则需要使用return语句将结果数据返回。
				                注意：
						          1。
				



				Java中的方法

构造器：
              作用：
	                1，配合newe关键字在堆内存中创建对象；
			2，对创建的对象的属性（成员变量）进行初始化；
			3，定义一些其他初始化代码。
		定义：
		         方法名是类名：
			 没有返回值类型；
			不需要return语句；

		具体定义：
		         权限修饰符 类名（参数1[,参数N]）{
			          方法体；
			 }
			 单例模式：
                       
		               
			   this关键字：
			          1.指代本类对象
				  2.指代本类的构造器，在本类的构造器中调用其它的构造器；
                                  3.当使用this调用奔雷的构造器的时候，该this语句只能放在第一句代码位置；
				  4.在构造器中只能再多只能出现一次this语句来调用本类中的构造器。


匿名对象：
             class Person{
	     int age;
	     void say(){
	      syso(this.age);
	      }
	      }








		int[] nums=new int[10];常用写法
		int num[]= new int[10];

		说明：创造一个int类型的数组名叫nums 在该数组的

		数组中元素的访问：
		                  索引：访问数组中的每个元素的方式，用于表示该元素在数组中的位置，
				  索引通常从，从0开始，步长为一，索引的最大值是数组的长度减一


分支控制：
	if-else：
	switch-case：
		switch(Key){
			case 常量1:{
				代码1;
				[break;]
			}
			case 常量2:
			case 常量3:
			case 常量4:
			default:{
			}
		}
循环控制：
	for：
		for(初始化语句;循环条件;增量/循环控制量的改变语句){
			循环体;
		}
		1、通过初始化语句初始化循环控制量；
		2、判断循环条件是否成立；
		3、如果成立，执行循环体；反之，终止循环。
		4、如果第三步成立执行完循环体之后，改变循环控制量的值；
		5、如此重复2到4步，直到循环条件不成立为止，终止循环。

		for(;;){}

		for(int i=0;i<100;i++){
			syso(i);
		}
		syso(i); // 编译错误

		for循环中声明的循环控制变量只是for循环中的局部变量，作用域for循环的代码块，出了for循环代码块，就不能访问了。
	while：
		while(循环条件/布尔表达式){
			循环体;
		}
		1、判断循环条件是否成立，如果成立执行循环体；如果不成立终止循环；
		2、重复执行第1步；
		注意：在while循环中控制循环条件，防止死循环。

		int i=0;
		while(i<100){
			循环体;
			i++;
		}

	do-while：
		不同：do-while不管循环条件是否成立，至少会执行一次循环体。









二维数组：数组的元素是一维数组。
            声明：
	                 int[][] numss=new int[5][5];
			  
			  int[][]numss=new int[3][];
			  只声明了二维数组的长度没有声明该二维数组的元素（一维数组）的长度。
			  以上数组声明不能直接使用，在使用之前需要对二维数组的每一个元素进行初始化，才能使用
  
		      int[][] numss=new int[][];//error
		       int[][] numss=new int[][]{};//error
		        int[][] numss=new int[][]{{1,2}{1,2,3}{3,4}};


			二维数组的使用
			      赋值：
			                int[][] numss=new int[3][2];
					numss[0][0]=10//给二维数组的第一个元素的第一个元素赋值
			    取值：
			              int[] nums=numss[0]；

				     int num=numss[0][1];
                                      

         数组的边界  ： 数组的索引的取值范围
	                int[] nums=new int[10];
			数组长度：int in=nums.length;
			   数组的length属性是不可以更改的，也就是nums.length=20；是错误的。

			  如何更改数组的长度：由于数组的属性length是不可以更改的，所以只能创建数组对象，重新设置长度。
			  int[] nums=new int[5];
			  nums[0]=100;
			  nums[1]=200;
			  nums[2]=300;
			  nums[3]=400;
			  nums[4]=500;


                          int[] temp=new int[6];
			  temp[0]=nums[0];
			  temp[1]=nums[1];
			  temp[2]=nums[2];
                          temp[3]=nums[3];
			  temp[4]=nums[4];
			  temp[5]=600;

       数组的遍历：使用循环来获取数组中的每一个元素。
       数组的联系
                       计算int类型中


排序：
     冒泡排序；
     让元素和气泡一样，根据大小顺序一个一个的呈现出来。
      使用双层循环，
      int[] nums={8,6,9,1,7,5,2,4,3,0};

          for(int x=0;x<nums.length;x++){
	              for(int z=0;z<nums.length-x-1;z++){
		              if(nums[z]>nums[z+1]){
			          int temp=nums[z]
                                 
			      }
		      }
	  }
     选择排序；
     插入排序



     面向对象的






     方法的重载：
                        在同一个类中，定义多个方法名相同但是形参不同的现象称之为方法的重载。

	形参不同：
	               1.参数的类型不同
		       2.参数的个数不同
		       3.参数的顺序不同・
	方法的重载只和方法的形参有关 与返回值类型无关


		       main（）{
		           student stu =new Student();
			   stu.add(1,2);
		       }

      
     参数的传递;
      Java中的参数是以什么形式传递？
          值传递  引用传递 

	  Java中只有值传递没有引用传递








	 练习2：下面的代码执行结果是什么
	 多态：
	             class Student extend person{
		     void study(){
		     }
		     }




成员是组成对象的基本方法

成员的特点：
        变量 ：子类访问成员变量时，
	              1.子类中有 父类中也有，会访问子类中的变量
		      2.子类中没有，父类中有，会访问父类中的变量。
		      3.子类中有，父类中没有，回访子类中的变量。
		      4.子类中没有 父类中也没有，在编译器报错
	   方法： 和成员表变量没有区别。但是在子类中和父类中具有相同名称和相同参数列表的现象称之为方法的重写。
	                      方法的重写：
			      方法的重载： 发生在同一个类中，方法名必须相同，参数列



构造器：方法名和类型名相同，没有返回值类型，虽然构造器也是方法

体现多态的三要素：
          1.必须要有继承
	  2.必须要有重写
	  3.必须要引用执行子类对象。


	  以成员的角度去



	  方法：





多态的好处：
       1.减少代码量。
       2.具有某种关系的多各类中的共性代码进行抽取，然后封装成方法，
            然后在传递参数的时候以这些类的父类进行参数传递。
多态的应用
           
	          


static关键字：
        1.static关键字能够修饰类（仅限于内部类）
	2.static修饰的变量被该类的所有对象所共享。
	3.静态方法能够直接访问静态变量和静态方法，但是不能直接访问非静态变量和非静态方法，如果需要访问非静态方法和变量，必须创建该类对象
	4。非静态方法可以直接访问静态方法和变量，也可以访问非静态方法和变量
	5.静态代码块和构造代码块的写法相似，只不过在代码块的起始位置有static关键字  并且静态代码块与构造代码块基本相同 
	    但静态代码块只随着类的加载而加载一次，构造代码块随着构造器执行而执行
	6.父类中的静态方法只能被子类继承但不能被子类重写：如果子类中出现了和父类中同名同参数列表的方法，
	     此时子类中的方法是不能称之为重写，但子类中的方法也必须是静态的 父类中非静态的方法不能被子类重写为静态的。
	7.
	8.静态变量被所有对象所共享，也可以不创建对象使用类名直接调用，那麽可不可以将所有对象都用static修饰


	第六章：Java高级编程之第一部分
目标：
	1.static关键字：静态变量，静态方法，静态代码块和静态导入。
	2.final关键字：final修饰的类、变量和方法
	3.访问控制：public，private，protected，default
	4.抽象类和抽象方法
	5.接口
	6.内部类
	7.Object类和String类

static关键字：
 一，特点：
	1.static关键字能够修饰类（仅限于内部类），变量，方法；static修饰的变量称之为静态变量或者叫类变量，
	    static修饰的方法称之为静态方法或者类方法。类变量和类方法区分于成员变量和成员方法；

	2.static所修饰的变量被该类的所有对象所共享；

	3.静态方法能够直接访问静态变量和静态方法，但是不能直接访问非静态变量（成员变量）和非静态方法（成员方法），
	   如果需要访问非静态变量和方法，必须创建该类的对象类访问。

	4.非静态方法可以直接访问静态变量和静态方法，也可以直接访问非静态变量（成员变量）和非静态方法（成员方法）。

	5.静态代码块和构造代码的写法类似，只不过在代码块的起始位置有static关键字，并且静态代码块的作用和构造代码块的作用基本一致，
	   但是静态代码块只随着类的加载而执行一次，构造代码块随着构造器的执行而执行。当静态代码块和构造代码块同时出现在一个类中的时候，
	   静态代码块优先于构造代码块执行。
		构造代码块：
			{
				代码;
			}

		静态代码块：
			static{
				代码;
			}

	6.父类中的静态方法只能被子类继承，不能被子类重写；如果子类中出现了和父类中同名同参数列表的方法，
	此时子类中的方法不能称之为重写，但是子类中的方法也必须静态的；父类的非静态方法不能被子类重写为静态。
	子父类中出现了同名同参的方法，要么都静态，要么都非静态。

	7.被static所修饰的变量和方法可以由类名直接调用，也可以使用该类的对象调用，但是前者居多。

	△8.由于静态变量被所有对象所共享，也可以不创建对象使用类名直接调用，那么可以不可以将一个类中的所有成员被静态修饰呢？
	答：分情况。从Java代码角度理解没有问题。但是从实际情况来理解有问题，类是具有相同属性和相同行为的一类事物的抽象，
	对象是其中的一个个体，每个对象所对应的属性值不尽相同，如果类中的所有属性都被静态修饰，此时该类的每个对象获取到的值都是一致的，
	和实际情况不符合。所以在设计类的时候，需要考虑应该将哪些属性设置为静态，哪些属性不能设置为静态，而不能单纯的为节省内存空间将所有的属性都设置为静态。

	△9.静态导入：将一个类中的静态属性进行导入。
		语法：import static 包.类.静态属性;
		语法：import static 包.类.*;

		import java.util.*;
		import java.util.Arrays;

		Scanner sc=new Scanner(System.in);
		Arrays.toString();

		java.lang.*;
		String

		import static java.lang.System.out;
		import static java.lang.System.in;

		Scanner sc=new Scanner(in);

		out.println();
		out.println();
		out.println();
		out.println();

	10.main方法：
		定义：public static void main(String[] args){}

		public：Java规定main必须是public修饰。

		static：由于JVM在执行代码的时候只有当主方法执行了之后才能创建关于类的对象，在没有对象之前，JVM如果要调用main方法，则main方法必须是static修饰。
			class Demo{
				main(){
					syso("aaaa");
				}
			}

			> javac Demo.java
			> java Demo
			上面的代码“java Demo”实际上是JVM在调用“Demo.main()”。
		
		void：由于JVM直接调用某个类的main方法，但是JVM不需要这个方法给她返回任何值，所以返回值类型是void。

		main：方法名。

		String[] args：在执行某个类的时候传递给主方法的形式参数。
			问：如何给main方法传递实际参数呢？
			答：在使用java命令执行某个类的时候，将参数直接跟在类名后面即可，
			        多个参数之间以空格分割；如果参数中本身就包含空格，则将该参数使用双引号包裹。
小浣熊
		
		class MainTest{
			main(String[] args){
				syso(args.length);
			}
		}

		全局静态常量：
		            定义：public static final 常量名=值；
			    例如：public static final String 

抽象类：
          抽象类定义的是众多类的共性。
	  2.从Java代码角度理解;抽象类就是被abstract修饰的类。被abstract修饰的方法叫做抽象方法。
	  3.抽象类也可有一般方法
	  4.抽象类中有构造器，但不能直接创建对象，在抽象类中可以显示的定义多个构造器
	  7.抽象方法指的是abstract修饰的没有方法体的方法，抽象方法所在的类一定是抽象类，抽象类中不一定有抽象类。
	  8。抽象类和普通类一样不能多继承 只能单继承。
9.抽象类的声明方法
              【public】   abstract class 类名{}





内部类;在类的内部定义的类；  内部类所在的类称之为外部类 
    1.成员内部类：
                     访问内部类的数据：先创建外部类对象，通过该对象的外部类对象访问




集合 ：
        Iterator it = coll.Iterator();
	 while (it.hasNext()){
	 Object obj = it.next();
	 
	 }

	 public Mylist(){
	Ob objs =new 
	 }
	 数组 ：
	       查询 更改  效率高
	       删除 添加  效率低








	       错误的概念： 与代码无关   如服务器宕机   
	       异常的概念：   程序得不到正常的结果
	         
		 一场默认的处理机制：
		                                    主调函数【上一级】   被调函数      JVM：获得异常对象
						                                                                           e.printStackTrace();
		用户也可以自己抛出异常
		        


	       注意：catch异常时  范围大的放下面
	             finally 不可以单独出现   里面放额外需要清理的资源 代码
                    在离开tre 。。。catch 块之前执行finally清除额外资源



		    throw 抛出异常对象
		    throws  声明该函数内存可能会出现的异常 且向上传递






		    返回值是int型不是byte型；
		       byte有可能出现1111 1111  值为-1
		       无法与文件尾部的-1进行区分 




 371

