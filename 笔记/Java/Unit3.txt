第三章：表达式和流程控制
目标：
	1.成员变量和局部变量
	2.成员变量的初始化
	3.发现并修复代码中的Bug
	4.Java中的操作符
	5.基本数据类型的求值
	6.布尔表达式/逻辑表达式
	7.流程控制语句

2，成员变量的初始化
class Student
{
              String name；
	      int age；
      
      //无参构造器
	      Student（）{
                             name="Keving";
			     age=26;
	      }
	      //方法的形式参数
	      //在定义方法时  方法名后面的括号中的参数
	      //方法中的形参就相当于在该方法中定义的局部变量
           Student(String name,int age){
                           this.name=name;
			   this.age=age；
                  } 

   //"kevin"  17实际参数

	      Student stu = new Student（"kevin",17）；
}
构造器赋值：通过构造器传递参数的形式，将某个值（实参）传递给成员变量。
      构造器;又称构造方法，指的是以类名为方法名的并且没用返回值的方法。

      在类中，如果没有显式的定义构造器，在该类中有一个默认的无参构造器。
      在类中，如果显式定义了构造器，则不会再有默认的无参构造器；如果想要用无参构造器创建对象，
                     在显示的定义一个无参构造器
4.Java中的操作符（在补码进行操作）：
成员变量初始化：
	1、直接赋值
		class Student{
			int age=10;
		}
	2、通过构造器赋值
		class Student{
			int age;

			Student(){
				this.age=10;
			}

			Student(int age){
				this.age=age;
			}
		}

		Student stu=new Student(20);

	1.Assignment Operators，赋值操作符
		=：直接赋值操作符。
			int num=10;

		+=：先加再赋值；
			int num=10;
			num+=10; -> num=num+10; -> num=20;
		-=：先减再赋值；
		*=：先乘再赋值；
		/=：先除再赋值；
			int num=10;
			num/=2;		num=num/2;		num=5;
		%=：先取余再赋值；
			int num=10;
			num%=2;		num=num%2;		num=0;

		<<=：有符号左移，针对于二进制数的补码，然后向左移动相应的位数。
			int num=10;
			num<<=2;	num=num<<2;		num=40;

		0000 0000 0000 0000 0000 0000 0000 1010   10
	        0000 0000 0000 0000 0000 0000 0000 1010     <-
		0000 0000 0000 0000 0000 0000 0010 1000	  40

			int num=10;
			num<<=3;	num=num<<3;		num=?

		0000 0000 0000 0000 0000 0000 0000 1010   10
	 0000 0000 0000 0000 0000 0000 0000 1010     <-
		0 0000 0000 0000 0000 0000 0000 1010000	  80
		
		int num=-10;
		num<<=2;	num=-10*2^2=-40

		1000 0000 0000 0000 0000 0000 0000 1010  原码
	  1111 1111 1111 1111 1111 1111 1111 0110    补码
	    11 1111 1111 1111 1111 1111 1111 011000  补码
		10 0000 0000 0000 0000 0000 0000 101000  原码

左移操作：num<<=N;	num=num*2^N;

		>>=：有符号右移，针对于二进制数的补码，然后向右移动相应的位数。

		int num=10;
		num>>=2;	num=num>>2;		num=2;
	
			0000 0000 0000 0000 0000 0000 0000 1010     10
		  0000 0000 0000 0000 0000 0000 0000 1010   ->
		000000 0000 0000 0000 0000 0000 0000 10     2

		num>>=3;	num=num>>3;		num=1;
	
		0000 0000 0000 0000 0000 0000 0000 1010     10
		   0000 0000 0000 0000 0000 0000 0000 1010  ->
		0000000 0000 0000 0000 0000 0000 0000 1     1

	                                                                                                                                                                                                                                     	int num=-10;
		num>>=2;	num=-3

		1000 0000 0000 0000 0000 0000 0000 1010    原码
		1111 1111 1111 1111 1111 1111 1111 0110  补码
		111111 1111 1111 1111 1111 1111 1111 01    补码
		100000 0000 0000 0000 0000 0000 0000 11	   原码

右移操作：num>>=N;	num=num/2^N;
                 1，只适用于正数。
		 2，要求余数必须为正数。
 余数：
      1，在数学上，余数的绝对值要小于除数的绝对值。
      2.，在Java中，必须要遵守数学上的规则，余数的符号还必须要与被除数的符号一致

		>>>=：无符号右移：
			正数：和>>=没有区别。
			负数：先将负数转化成对应的补码，然后右移，然后前面补0，然后转化成原码，再转化成10进制。
		int num=-10;
		num>>>=2;	num=?
		
		1000 0000 0000 0000 0000 0000 0000 1010    原码
		  1111 1111 1111 1111 1111 1111 1111 0110  补码
		001111 1111 1111 1111 1111 1111 1111 01    补码
		001111 1111 1111 1111 1111 1111 1111 01    原码

		负数经过无符号右移之后会变成一个很大的数。

		人为进行计算：
		正数：原码（补码）=》移位操作=》补码（原码）=》十进制
		负数：原码=》反码=》补码=》移位操作=》补码=》反码=》原码=》十进制

		&=：按位与（合取1是0否）操作符：
			1&1=1;	1&0=0;	0&0=0;
		
			int num=10;
			num&=5;	 ->	 num=num&5;		->	num=0

			0000 0000 0000 0000 0000 0000 0000 1010
			0000 0000 0000 0000 0000 0000 0000 0101
			---------------------------------------
			0000 0000 0000 0000 0000 0000 0000 0000	 = 0

			int num=-10;
			num&=5;		num=num&5;		num=4

			1111 1111 1111 1111 1111 1111 1111 0110
			0000 0000 0000 0000 0000 0000 0000 0101
			---------------------------------------
			0000 0000 0000 0000 0000 0000 0000 0100	 = 4

			int num=-10;
			num&=-5;	num=num&-5;		num=?

			1111 1111 1111 1111 1111 1111 1111 0110
			1111 1111 1111 1111 1111 1111 1111 1011
			---------------------------------------
			1111 1111 1111 1111 1111 1111 1111 0010
			1000 0000 0000 0000 0000 0000 0000 1110  = -14

		|=：按位或（析取 1是0否）操作：
			1|1=1;	1|0=1;	0|0=0;

		正数|正数：
		int num=10;
		num|=5;		num=num|5;		num=15

		0000 0000 0000 0000 0000 0000 0000 1010
		0000 0000 0000 0000 0000 0000 0000 0101
		---------------------------------------
		0000 0000 0000 0000 0000 0000 0000 1111  = 15

		负数|负数：
		int num=-10;
		num|=-5;		num=num|-5;		num=-1

		1111 1111 1111 1111 1111 1111 1111 0110（-10的二进制补码）
		1111 1111 1111 1111 1111 1111 1111 1011（-5的二进制补码）
		---------------------------------------
		1111 1111 1111 1111 1111 1111 1111 1111
		1000 0000 0000 0000 0000 0000 0000 0001  = -1

		正数|负数：
		int num=-10;
		num|=5;		num=num|5;		num=-9

		1111 1111 1111 1111 1111 1111 1111 0110
		0000 0000 0000 0000 0000 0000 0000 0101
		---------------------------------------
		1111 1111 1111 1111 1111 1111 1111 0111
		1000 0000 0000 0000 0000 0000 0000 1001  = -9
		正数|正数=正数；
		正数|负数=负数；
		负数|负数=正数；

		^=：按位异或，相同为0，不同为1；
		
		int num=10;
		num^=5;		num=num^5;		num=15

		0000 0000 0000 0000 0000 0000 0000 1010（10的原码（补码）10为正数）
		0000 0000 0000 0000 0000 0000 0000 0101
		---------------------------------------
		0000 0000 0000 0000 0000 0000 0000 1111	 = 15

		

~：取反操作符；

		int num=10;
		num=~num;		num=-11

		0000 0000 0000 0000 0000 0000 0000 1010 （10的原码 因为是正数所以补码==原码）
		1111 1111 1111 1111 1111 1111 1111 0101（对10的补码进行取反操作     得到的是补码）
		1000 0000 0000 0000 0000 0000 0000 1011  =  -11      （对补码进行取反加1得到原码）

		int num=9;
		num=~num;		num=-10

		0000 0000 0000 0000 0000 0000 0000 1001
		1111 1111 1111 1111 1111 1111 1111 0110
		1000 0000 0000 0000 0000 0000 0000 1010  =  -10

		int num=-10
		num=~num;		num=9
		1111 1111 1111 1111 1111 1111 1111 0110
		0000 0000 0000 0000 0000 0000 0000 1001  =  9

原数值加1取相反数。

	2.Comparison Operators：比较操作符，结果是boolean类型。
		> ：大于。
			1>2：false
			2>1：true

		>=：大于等于。
			2>=2：true
			2>=1：true
			2>=3：false

		< ：小于。
		<=：小于等于。
		==：用来判断该符号左右的两个数据的内存地址是否相同。
			int a=1;
			int b=1;
			a==b：true

			1==1：true
			1==2：false

		!=：用来判断该符号左右的两个数据的内存地址是否不同。
			1!=1：false
			1!=2：true



		instanceof：关键字。结果true或者false。
			对象 instanceof	类
			判断左边的对象是否右边的类的对象。

		class Student{}

		class Teacher{}

		Student stu=new Student();

		Teacher tea=new Teacher();

		stu instanceof Student      --->	true
		stu instanceof Teacher		--->    false

	3.算术操作符：
		+：
			1.用于数学计算：
				int num=1+1;

				int a=10;
				int b=a+10;

			2.用于字符串拼接：
				String str1="Hello";
				String str2="World";
				String str3=str1+str2+"Briup"+6+7;
					   str3="HelloWorldBriup67";

				String str4="Kevin";
				syso(100+str4);		======> 100Kevin
				syso(100+200+str4);	======> 300Kevin//当数学算式在字符串前是进行计算        
				syso(100+200+str4+100);	======> 300Kevin100//字符串在前时后面的数据都作为字符串进行输出。

		-：数学运算。
			int x=100-12;
			
			int a=10;
			int b=a-1;

		*：数学运算。
		/：数学运算。取商。
		%：数学运算。取余。
		
		++：累加操作符，步长为1
		- -；累加操作符，步长为-1
		                        num++；
					              先让num参与其他代码的执行，执行完毕后在对num累加1；
			              ++num；
				                     先进行+1操作，再参与代码的执行。
				      num - -；
				                      先让num参与其他代码的执行，执行完毕后在对num累加-1；
				      - -num；
					          先进行-1操作，再参与代码的执行。
	4.逻辑操作符（短路操作符）：    (左右必须是布尔类型   ture和false代表判断语句)
 		&&：逻辑按位与
	    true&&true=true                   （当先遇到的逻辑表达式为false是便不再向后执行  如果先执行的逻辑表达式为true则继续向后执行第二次执行结果为什么就是神马）
            true&&false=false
            false&&fasle=false
	   
	    &&：短路与。左右需要布尔表达式。
	int num=10;
	if(num++>0||--num<10){
		syso("haha");
	}else{
		syso("hehe");
	}

	if(num++>10&--num<10){
		syso("haha");
	}else{
		syso("hehe");
	}
            
		||：逻辑按位或
            true||true=true
            true||false=true
            false||fasle=false

	5.条件运算符：?:，三目运算符。

		!true	单目运算符
		1+1		双目运算符

		条件表达式(逻辑表达式)?代码1:代码2;     三目运算符   （两个表达式的结果需要以同一种类型表现出来  
		                                                                                             小类型需要转换为大类型进行输出）

		当问号前面的条件表达式为true的时候执行代码1，为false的时候执行代码2；可以被if...else...语句代替。

		int num=10;
		num>=10?num=9:num=100;2q'q
		
6.逻辑表达式
	表达式的结果是true或者false的表达式。
	逻辑表达式多用于if语句或者while循环语句。

7.流程控制语句
	1.if...else...语句：用来判断某个条件是否成立，用于执行不同的操作。
	语法：
		if(布尔/逻辑表达式){
			代码1
		}else{
			代码2
		}

	说明：如果“布尔/逻辑表达式”成立，为真，为true，则执行代码1；否则执行代码2。

	if...else...语句中的代码的大括号只有当该代码只有一行的时候可以省略。

		int num=10;

		if(num>10) syso("haha");
		else syso("hehe");
		
		System.out.print(num>10?"haha":"hehe");
	
	语法：
		if(逻辑表达式1){
			代码1
		}else if(逻辑表达式2){
			代码2
		}
			.
			.
			.
		else if(逻辑表达式N){
			代码N
		}else{
			代码N+1
		}
	说明：先判断逻辑表达式1，如果成立，则执行代码1；否则，判断逻辑表达式2，如果成立则执行代码2，否则，一直判断到逻辑表达式N，如果成立执行，代码N，否则执行代码N+1。
		
		double score;
		if(score>80&&score<=100) System.out.println("A");
		else if(score>70&&score<=80) System.out.println("B");
		else if(score>=60&&score<=70) System.out.println("C");
		else if(score<60&&score>=0) System.out.println("不及格");
		else System.out.println("成绩有误！");

	语法：
		if(逻辑表达式1){
			代码1
		}
		if(逻辑表达式2){
			代码2
		}
		...
		if(逻辑表达式N){
			代码N
		}
	2.switch-case
		语法：
			switch(Key){
				case 常量1:{
					代码1;
					[break;]
				}
				case 常量2:{
					代码2;
					[break;]
				}
				case 常量3:{
					代码3;
					[break;]
				}
					...
				case 常量N:{
					代码N;
					[break;]
				}
				default:{
					代码N+1;
				}
			}

		说明：对常量1到常量N和Key进行匹配，如果匹配到哪个case，就执行哪个case中的代码。

		举例：给出数字月份，打印出相应的汉字月份。
			int month=10;
			switch(month){
				case 1:{
					syso("一月份。");
					break;
				}
				...
				default:{
					syso("月份错误。");
				}
			}

		注意：
			1、Key的数据类型可以是byte、char、short、int和String。
			2、如果switch-case语句中没有break，则从匹配到的case开始执行一直执行到switch代码块结束或者一直执行到遇到break则结束，
			      最好给每个case中的代码最后都加上break。
			3、每个case后面的常量必须不同。
			4、当某一些case的代码相同的时候，可以将这些case放在一起，此时，只需要对最后一个case加break语句即可。
			
		练习：给出数值月份，判断该月有多少天。
			int month=1;
			switch(month){
				case 1:
				case 3:
				case 5:
				case 7:
				case 8:
				case 10:
				case 12:{
					syso(month+"月份的天数是31天。");
					break;
				}
			}
			5、default分支可以放置在switch中的任意位置，但是如果default分支所处的位置不是最后一个，
			      则在default中需要加break。
			6、最后一个case可以不加break。
			7、switch-case语句的功能可以由if-else代替，但是if-else语句的功能更强大。
			8、case后面的大括号可以省略，但是switch的行。case是Java中唯一一个可以在有多行代码的情况下
			      省略大括号的语句。

		

	3.循环控制语句
		一直重复的执行某一些代码，直到循环条件达到循环终止条件，则终止循环。
		1、for
		语法：
			for(初始化语句;循环条件;增量){
				循环体;
			}
		说明：初始化语句给出循环的初始条件，经过循环条件的判断，如果符合循环条件，则执行循环体；
		            之后增量改变循换控制量的值再判断改变之后的条件是否符合循环条件，如果符合继续循环执行，
			    直到循环条件不满足为止。

		例子：循环打印100次“HelloWorld！”。
			for(int i=0;i<100;i++){
				System.out.println("Hello World!");
			}

		for循环的执行流程：
			1、先执行初始化语句，该语句只在第一次循环的时候执行，后面不再执行。
			2、判断循环条件是否成立；
			3、如果成立，执行循环体；如果不成立，结束循环。
			4、通过增量更改循环控制量的值。
			5、一直做2-4步的操作，直到循环条件不成立结束循环为止。
			
			for(;;){}

		for(int i=0;i<100;i++){
			syso(i);
		}
		syso(i); // 编译错误

		for循环中声明的循环控制变量只是for循环中的局部变量，作用域for循环的代码块，出了for循环代码块，就不能访问了。
		
		练习1：使用循环计算1到100的和。
			int sum=0;
			for(int i=1;i<=100;i++){		
				sum+=i;
			}
			syso(sum);

		练习2：计算1到100的偶数的和。
			int sum=0;
			for(int i=2;i<=100;i+=2){
				sum+=i;
			}

		练习3：计算100到999之间的所有水仙花数。153,370,371,407
			如何得到个位，十位和百位的值。

			153：
				3：153%10=3;
				5：153/10%10;
				1：153/100;

			for(int i=100;i<1000;i++){
				int g=i%10;
				int s=i/10%10;
				int b=i/100;

				int sum=g*g*g+s*s*s+b*b*b;
				if(sum==i){
					syso(i+"是水仙花数。");
				}
			}

		练习：计算1到100之间的质数，素数。

		死循环：
			for(;;){
				syso("haha");
			}

		2、while
			语法：
				while(循环条件/布尔表达式){
					循环体;
				}

			说明：当循环条件成立的时候，即布尔表达式为true的时候，会执行循环体，否则终止循环。在while循环中，
			要注意控制循环条件，否则可能会造成死循环。

			例子：
				int num=10;
				while(num<=10){
					syso("haha");
				}

			练习：使用while循环计算1到100的和。
				int i=1;
				int sum=0;
				while(i<=100){
					sum+=i;
					i++;
				}
				//---------------------------------
				int i=1;
				int sum=0;
				while(i<=100){
					sum+=i++;
				}
		3、do-while
		语法：
			do{
				循环体;
			}while(循环条件);

		说明：先执行一次循环体，然后判断循环条件是否成立，如果成立，再执行循环体，直到循环条件不成立为止。

		和while的区别：如果循环条件不成立，while循环直接终止；而do-while循环会执行一次循环体。

		死循环：
			while(true){}
			do{}while(true);
			
			while(false){}
			do{}while(false);
过一个保护你
		4、循环嵌套：循环套循环.
			for套for：
			
			for(int i=0;i<5;i++){
				for(int x=0;x<5;x++){
					System.out.print("*");
				}
				System.out.println();
			}
		
			*****
			*****
			*****
			*****
			*****



			例子：打印九九乘法表。
			
			*
			**
			***
			****
			*****
			******
			*******
			********
			*********
			for(int i=0;i<9;i++){
				for(int x=0;x<=i;x++){
					System.out.print("*");
				}
				System.out.println();
			}
				
			*********
			********
			*******
			******
			*****
			****
			***
			**
			*
			for(int i=0;i<9;i++){
				for(int x=9;x>i;x--){
					System.out.print("*");
				}
				System.out.println();
			}

			例子2：打印杨辉三角

							1
						  1   1
						1   2	1

			for嵌套while：
			while嵌套while：
		5、循环中的跳转：
			break [label]：中断代码的执行；终止当前循环的执行；如果break后面跟一个标签的话，终止多层循环。
			
			for(int x=0;x<5;x++){
				for(int z=0;z<5;z++){
					System.out.println(x+":"+z);
				}
			}

			continue [label]：跳过本次循环，继续下次循环。

			class Student{
				main(){
					http://www.baidu.com
					for(){}
				}
			}

			int x,a=6,b=7;
			x=a++ + b++ + a++ + b++;
			x=20;
			a=8;
			b=8;

			// return; 结束方法的执行。

			int sum=0;
			for(int x=1;x<=10;x++){
				sum*=i;
			}

