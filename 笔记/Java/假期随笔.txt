假期随笔：

            



	    SSM： Spring_SpringMVC_mybatis



         问题:              
	                   1，我在数据库中建立索引后为什么不会提高查询速度   索引是否由SQLServer默认使用
                                 聚集索引和非聚集索引的创建方式有无不同
                            







       Java基础内容：
                       一，标识符的命名规则 ：
			      只能以字母  "_"   "$"开始 后面的字符是除了特殊字符以外的字符  不能以数字开头
			      标识符就是 类 方法 变量 和常量名
			      变量：是JVM管理的一片内存空间，该空间的值可以改变。
	                                  变量三要素：数据类型、变量名、变量值。

                              1.类名：首字母大写
			      2.方法名：第一个单词首字母小写  之后的单词首字母全部大写
			      3.变量名：与方法名相同
			      4.常量名：不管有几个单词全部大写





			  二，  八种基本数据类型特点及其转换方式：
			      一字节       字节型  byte      布尔型 boolean
			      二字节       短整型  short     字符型  char
			      四字节       整型      int         单精度浮点型 float
			      八字节       长整型  long       双精度浮点型 double
			      
			      
			      小转大 直接转   大转小  需要强转        
			      eg：
			             int x=10;     
				     long y=90L;
				     y=x;
				     x=(int)y
			    
			     高精度转低精度 直接转换    低精度转换高精度  需要强转  有可能会丢失精度  整型转换浮点型肯定
			     丢失精度
			     eg:  
			           int x = 80;
		                  double y=12.23;
		                  float z=(float) 345.9123;
                                  y=z;
		                  z=(float) y;
	                          System.out.println(y);
		                  System.out.println(z);
		                   x=(int) y;
		                  y=x;
		                  System.out.println(x);

			      
			      
			      
			      
			      
			      
                 三， Java中的操作符  (计算)：
			      正数的 源码和补码相同   负数的补码源码取反加一
			      符号(首个数字为0 是正数  首个数字为1 是负数)
			      余数：
                                    1，在数学上，余数的绝对值要小于除数的绝对值。
                                    2，在Java中，必须要遵守数学上的规则，余数的符号还必须要与被除数的符号一致
		<<=：有符号左移，针对于二进制数的补码，然后向左移动相应的位数。
			int num=10;
			num<<=2;	num=num<<2;		num=40;

		0000 0000 0000 0000 0000 0000 0000 1010   10
	        0000 0000 0000 0000 0000 0000 0000 1010     <-
		0000 0000 0000 0000 0000 0000 0010 1000	  40
			      左移操作：num<<=N;	num=num*2^N;
	        
		>>=：有符号右移，针对于二进制数的补码，然后向右移动相应的位数。
		num>>=3;	num=num>>3;		num=1;
	
		0000 0000 0000 0000 0000 0000 0000 1010     10
		   0000 0000 0000 0000 0000 0000 0000 1010  ->
		0000000 0000 0000 0000 0000 0000 0000 1     1

	                                                                                                                                                                                                                                     	int num=-10;
		num>>=2;	num=-3

		1000 0000 0000 0000 0000 0000 0000 1010    原码
		1111 1111 1111 1111 1111 1111 1111 0110  补码
		111111 1111 1111 1111 1111 1111 1111 01    补码
		100000 0000 0000 0000 0000 0000 0000 11	   原码

右移操作：num>>=N;	num=num/2^N;
                 1，只适用于正数。
		 2，要求余数必须为正数。



		&=：按位与（合取1是0否）操作符：
			1&1=1;	1&0=0;	0&0=0;

                |=：按位或（析取 1是0否）操作：
			1|1=1;	1|0=1;	0|0=0;
                  
         	instanceof：关键字。结果true或者false。
			对象 instanceof	类
			判断左边的对象是否右边的类的对象。
	    （1）一个类的实例包括本身的实例，以及所有直接或间接子类的实例
            （2）instanceof左侧操作元显示声明的类型与右边操作元必须是同种类或有继承关系，即位于继承的同一个分支上，否则会编译出错
               
	       条件运算符：?:，三目运算符。 1)三目运算符必须有返回值 不可以是赋值运距或是输出语句    
	                                                           2)三目运算符运算性能高于if...else...
								   3)两者使用范围不同，在ireport的一些动态执行的情况下，只能用三元运算符而
								      不能用if-else语句，当然在大多数情况下两者是可以等价互换的




	   四，流程控制
			      1.if...else...语句：用来判断某个条件是否成立，用于执行不同的操作。 
			         if...else...语句中的代码的大括号只有当该代码只有一行的时候可以省略。
				       eg:
				            
		                                int num=10;
		                               if(num>10) syso("haha");
		                               else syso("hehe");
		                               System.out.print(num>10?"haha":"hehe");
			       if(){}..else if(){}...else if(){}...
			      当一个条件成立后不再执行其他条件	 

                              2.switch-case
		语法：
			switch(Key){
				case 常量1:{
					代码1;
					[break;]
				}
				case 常量2:{
					代码2;
					[break;]
				}
				case 常量3:{
					代码3;
					[break;]
				}
					...
				case 常量N:{
					代码N;
					[break;]
				}
				default:{
					代码N+1;
				}
			}

		说明：对常量1到常量N和Key进行匹配，如果匹配到哪个case，就执行哪个case中的代码。

		举例：给出数字月份，打印出相应的汉字月份。
			int month=10;
			switch(month){
				case 1:{
					syso("一月份。");
					break;
				}
				...
				default:{
					syso("月份错误。");
				}
			}

		注意：
			1、Key的数据类型可以是byte、char、short、int和String。
			2、如果switch-case语句中没有break，则从匹配到的case开始执行一直执行到switch代码块结束或者
			       一直执行到遇到break则结束，最好给每个case中的代码最后都加上break。
			3、每个case后面的常量必须不同。
			4、当某一些case的代码相同的时候，可以将这些case放在一起，此时，
			      只需要对最后一个case加break语句即可。
                      


		五，  循环控制语句
                  1.for循环
		  语法：
			for(初始化语句;循环条件;增量){
				循环体;
			}
	           说明：初始化语句给出循环的初始条件，经过循环条件的判断，如果符合循环条件，则执行循环体；
		            之后增量改变循换控制量的值再判断改变之后的条件是否符合循环条件，如果符合继续循环执行，
			    直到循环条件不满足为止。
	           2.while循环：
		     语法：
				while(循环条件/布尔表达式){
					循环体;
				}

			说明：当循环条件成立的时候，即布尔表达式为true的时候，会执行循环体，否则终止循环。在while循环中，
			要注意控制循环条件，否则可能会造成死循环。
		   3.do_while循环
		       语法：
		              do{
				循环体;
			}while(循环条件);

		说明：先执行一次循环体，然后判断循环条件是否成立，如果成立，再执行循环体，直到循环条件不成立为止。
		和while的区别：如果循环条件不成立，while循环直接终止；而do-while循环会执行一次循环体。

               4， 循环嵌套
                 

	       5，循环中的跳转
	             1）break [label]：中断代码的执行；终止当前循环的执行；如果break后面跟一个标签的话，终止多层循环。
		     2）continue [label]：跳过本次循环，继续下次循环。
		     3）return; 结束方法的执行。




	   六，  数组
			      数组的声明和初始化
                                      语法：
				                数字类型[] 数组名=初始化语句；
				    第一种： 数组类型 [] 数组名= new 数组类型[数组长度]；
				    第二种：数组类型 [] 数组名 = new 数组类型[]{数组元素};
				    (静态初始化)
				    第三种：数组类型 [] 数组名 = {数组元素};		    
                             
					        
			      	数组中元素的访问：
		                        索引：访问数组中每个元素的方式，用于表示该元素在数组中的位置，索引通常从0开始，步长为1，
		                                   索引的最大值是数组的长度减1。 数组没有length方法  且数组的长度不可以改变

		                        赋值：
			                           语法：数组名[索引]=值;
		                        取值：
			                            语法：数据类型 变量名=数组名 [索引];
				        默认值：
					          char的默认值为空（不是null 也不是0）
						  byte默认值为0；
						  boolean默认值为false
						  非基本数据类型数组默认值为null
                                  
				  二维数组（数组元素是一维数组的数组）：
				                  二维数组的使用：
			                               赋值：
				                                int[][] numss=new int[3][2];
			                                    	numss[0][0]=10;
			                                取值：
				                                int[] nums=numss[0];
				                                int num=numss[0][1];

			数组的边界：数组的索引的取值范围。
		                             int[] nums=new int[10];
		                             数组的长度：int len=nums.length;
		                             数组的索引：int indexMin=0;int indexMax=nums.length-1;
			                     数组的length属性是不可更改的，也就是nums.length=20;是错误的。	                 
		如何更改数组的长度(数组的扩容)：由于数组的属性length是不可更改的，所以只能重新创建数组对象，
		重新设置长度。
						int[] nums=new int[5];
						nums[0]=100;
						nums[1]=200;
						nums[2]=300;
						nums[3]=400;
						nums[4]=500;

						int[] temp=new int[6];
						temp[0]=nums[0];
						temp[1]=nums[1];
						temp[2]=nums[2];
						temp[3]=nums[3];
						temp[4]=nums[4];
						temp[5]=600;

					数组的遍历：使用循环来获取数组中的每一个元素。
						if(temp.length<=nums.length) syso("数组长度不够！");

						for(int x=0;x<nums.length;x++){
							temp[x]=nums[x];
						}

						temp[temp.length-1]=600;

						nums=temp;

						temp=null;
			      三种基本排序方法
			      冒泡排序：
			                   /**
	 * 冒泡排序 ： 将相邻的数字进行比较 将较大(小)的都和相邻的进行 交换次序 每比较一次都会进行移动位置 
	 *           损耗资源 效率低 当j=0时
	 * 小于号是小到大 当j=i+1时 小于号是从大到小 较小的数字向后移动
	 */
						@Test
						public void bubbleSort() {
							int[] arr = { 123, 456, 78, 9, 3423, 6780, 23 };
							int x = 0;
							System.out.println(Arrays.toString(arr));
							for (int i = 0; i < arr.length; i++) {
								// for(int j=i+1;j<arr.length;j++){
								for (int j = 0; j < arr.length; j++) {
									if (arr[i] < arr[j]) {
										x++;
										arr[i] = arr[i] ^ arr[j];
										arr[j] = arr[j] ^ arr[i];
										arr[i] = arr[i] ^ arr[j];
										System.out.println(x + ":" + "" + Arrays.toString(arr));
									}
								}

							}
							System.out.println("结果：" + Arrays.toString(arr));
						}
			      选择排序：
          /**
	 * 选择排序：相邻的数字相互比较 将较大(小)的下标进行记录 内循环 结束后 进行交换次序
	 */
					@Test
					public void selectionSort() {
						int[] arr = { 123, 456, 78, 9, 3423, 6780, 23 };
						int temp = 0;
						int k;
						for (int i = 0; i < arr.length; i++) {
							k = i;
							for (int j = i + 1; j < arr.length; j++) {
								if (arr[k] > arr[j]) {
									k = j;
								}
							}
							temp = arr[i];
							arr[i] = arr[k];
							arr[k] = temp;
						}
						System.out.println(Arrays.toString(arr));
					} 
			       
			      插入排序：
	 /**
	 * 插入排序： 将前面的数字看作有序的
	 */
				@Test
				public void insertionSorting() {
					try {
						int[] arr = { 123, 456, 78, 9, 3423, 6780, 23 };
						int temp = 0;
						int j = 0;
						for (int i = 0; i < arr.length; i++) {
							temp = arr[i];
							for (j = i - 1; j >= 0; j--) {
								if (temp > arr[j]) {
									break;
								} else {
									arr[j + 1] = arr[j];
								}
							}
							arr[j + 1] = temp;
						}
						System.out.println(Arrays.toString(arr));
					} catch (Exception e) {
						// TODO: handle exception
						e.printStackTrace();
					}
				}
			        
			        this关键字：
	                               1.指代本类对象；
	                               2.指代本类中的构造器,在本类的构造器中进行本类其他构造器的调用；
	                               3.当使用this调用本类中的构造器的时候，该this语句只能放在第一句代码位置。
	                               4.在类的构造器中，最多只能出现一次this语句来调用本类中的其他构造器
	                         匿名对象：
	                              1.没有对象名的对象；
	                              2.当用new创建的对象只使用一次的时候；
	                              3.当将对象作为实参进行参数传递的时候；
	七，    Java的三大特性 封装  继承  多态   （方法的重载和重写 子父类的关系）

			      封装：
			              封装的意义(好处)： 1、良好的封装能够减少耦合。
                                                                       2、类内部的结构可以自由修改。
                                                                       3、可以对成员进行更精确的控制。  （get/set方法）
                                                                       4、隐藏  信息，实现细节。
			    方法重载(Overloading)：
	                                   在同一个类中，定义多个方法名相同但是方法的形参不同的现象称之为方法重载。

	                                   形参不同：
		                                            1.参数个数不同：
		                                            2.参数的数据类型不同：
		                                            3.参数的顺序不同：
					注意：重载只和参数相关，和返回值类型，权限修饰符无关。
                            参数传递：
	                                   Java中的参数是以什么形式传递的？值传递
	                                   Java中的参数传递只有值传递，没有引用传递。

	                 值传递：当传递给方法的参数是八种基本数据类型和String类型的时候，该参数的传递是值传递，在参数传递的过程中，
	                                将传递的实参所代表的值拷贝一份传递给形参，让形参来收。基本数据类型作为参数传递之后，不会改变
			                 原来的变量中存储的值。
		     引用传递：当传递给方法的参数是引用类型的数据的时候，此时是将该引用的地址(值)传递给了形参。
	                                当传递的是引用值的时候，改变了引用的对象的状态，原来的对象的状态也随之改变。
	                     引用：栈内存中的变量指向堆内存中对象的过程。

			    继承：object是所有类的父类  超类  
			                Java 只有单继承  但是可以多实现
					所有类都有继承关系  默认继承Object(隐式表示  不需要extends关键字) 用extends关键字表示 
					
						继承的特点：
						  子父类中的成员变量：

								1.如果子父类中存在相同名字的成员变量，则使用子类对象调用该变量时，子类中的变量会将父类
								   中的变量隐藏；如果使用父类对象调用该变量时，调用的是父类中的变量。
								2.子类不能直接访问父类中的私有（被private修饰的）成员变量和成员方法。
								3.如果父类中提供了某个私有成员的公共访问方式，子类可以通过该公共的访问方式来访问父类中
								    的成员。
								4.super关键字：
									1.当子类中具有和父类同名的成员时，super可以在子类中访问父类中的成员；
									    当子类中没有和父类中同名的成员，子类访问父类的成员可以使用super或者this。
									2.在子类的构造器中访问父类的构造器。
									3.super和this一样，也只能放在构造器中代码的第一行。
									4.super和this只能在构造器 或者成员方法中使用；而不能在静态方法或者静态代码块中使用。
									5.在子类的构造器中，如果没有this，会使用super隐式调用父类中的【无参构造器】；
									    因为子类继承自父类，子类必须知道父类中的成员。如果在父类中显式的定义了有参构造器，
									    则在子类中需要显式的调用父类的有参构造器。

						练习：super和this能不能同时出现？
						视情况而定，当super和this调用成员时，可以同时出现。
						当调用构造器时，不能同时出现，因为在调用构造器时，这两关键字必须都放在构造器代码第一行。

					  子父类中的成员方法：
								1.在子类中调用成员方法时，如果某方法在父类中有，子类中没有，则调用父类中的方法；
								   如果某方法在子父类中都有，则调用子类中的方法。此种现象称之为方法的重写（覆盖），
								    overriding。
								2.如果父类中的方法被私有化，则子类无法调用该方法。
					  方法的重写：
							     1，发生在子父类中
							     2.  方法名相同 形参相同 
							     3.子类方法的权限大于父类     抛出的异常小于父类方法 
							     4.子类不能重写父类中私用方法   因为子类中不能看到父类中的私有方法
							     5.静态方法不能重写

					方法的重写与重载的区别
							   1，重写发生在子父类中   重载发生在同一个类中。
							   2,   重写形参相同   重载 形参不同
							   3，重写要求抛出异常变小 权限变大    重载对 异常或权限 没有要求
           多态：
	            1.同一个对象具有多种形态。
	            2.一个对象只有一种类型。
	            3.一个变量可以有多种类型。
	            4.多态表现在运行时，而重载表现在编译时。
		                 
				 体现多态的三要素：
									1.必须要有继承；
									2.必须要有重写；
									3.父类引用指向子类对象。
				从成员的角度理解多态
				                    成员变量： （优先使用父类成员）  编译看左边，运行看左边。
						                      1，当同名成员变量父类子类都有    编译通过 执行访问父类成员
								      2，当同名成员变量父有子没有        编译通过   执行访问父类成员
								      3，当同名成员变量父没有子有        编译报错  找不到符号 
								      4，当同名成员变量父没有子没有     编译报错  找不到符号
						    成员方法：（优先使用子类成员）  编译看左边，运行看右边。
						                   注意：静态方法有所区别，编译看左边，运行看左边。  静态方法无法重写
						                      1，当同名成员方法父有子有           编译通过  执行子类方法
								      2，当同名成员方法父有子没有       编译通过  执行父类方法
								      3，当同名成员方法父没有子有       编译报错  找不到符号
								      4，当同名成员方法父没有子没有   编译报错  找不到符号
                               多态的好处：
							1.减少代码量；
							2.具有某种关系的多个类中的共性代码进行抽取，然后封装成方法，然后在传递参数的
							   时候以这些类的父类型进行参数传递。


				   尽量使用数据耦合 少使用控制耦合 限制公共耦合范围   尽量避免使用内容耦合

				    数据耦合：模块间通过参数传递基本数据类型
				    控制耦合：一个模块通过控制在界面上传递一个信号进行控制另一个模块
				    公共耦合：两个或两个模块之间使用同一个全局静态量
				    内容耦合：当一个模块直接操作另一个模块或者直接转入另一个模块时 就发生了内容耦合 
							  被修改的模块直接依赖修改他的模块
				                            
      Java高级编程：

                             static静态变量静态方法的加载过程
							 在new对象时静态代码加载顺序：
														父类静态代码块
														子类静态代码块
														父类构造代码块
														父类构造器
														子类构造代码块
														子类构造器
			   静态代码块在类加载的过程中就执行了   构造代码块和构造器是在执行new关键字是执行的
			   构造代码块先于构造器执行
                            static关键字可以修饰类 但是仅限于内部类


			     Java内部类的应用


			     接口和抽象类  ：
			            



			     权限修饰符  
							同包同类	      同包不同类   同包子类	不同包子类	不同包不同类
					public		   √			√		√			√			√		
					protected	           √			√		√			√			×		
					default		   √			√		√			×			×		
					private		   √			×		×			×			×         
			     

			     final修饰的方法 类  和变量：
			                    final修饰的方法不能被重写  可以被子类继承   
					    final修饰的类不可以被继承   Java中最常见的类是System类和String类
					    final修饰的变量称为常量   常量名必须大写  多个单词之间用下划线连接
					                       当final修饰的变量为全局常量时：必须显示初始化 且只能赋值一次
							               显示初始化的两种方法：
								                             1.final int NUM=100;
											     2.在构造器中：
													class Demo{
														final int NUM;
														Demo(){
															NUM=100;
														}
													}
								final修饰的变量为局部变量：在使用变量前必须要进行初始化 并且变量值不可以改变
                                                                
								全局静态常量：
									定义：public static final 数据类型 常量名=值;
									例如：public static final String COUNTRY="zh_CN";
									说明：final修饰的变量称之为常量，对于常量名的书写规范：
										1.如果常量名由一个单词组成则整个单词的所有字母都大写；
										2.如果常量名由多个单词组成则全部字母都大写，每个单词之间用下划线分割。
											final String COUNTRY="zh_CN";
											final String MY_COUNTRY="zh_CN";
							       
							       
							       
                             Object和String类：
			        Object类：在Java中，Object类是所有类的父类；
						 常见的方法：
							String toString();	返回当前类的对象的字符串表示形式。

							Class getClass();	返回的是当前对象所属的类在内存中的镜像。
								Class类中有一个方法：String getName()，该方法能够返回该类的名字。

							int hashCode();	返回的是当前对象的哈希值（内存地址值的十进制）。

							boolean equals(Object o);	返回的是判断调用该方法的对象和传入的参数对象的数据类型和数据内容（哈希值）
													是否一致。

							问：==和equals的区别？
							答：在基本数据类型中，==用于比较值是否相等；equals方法不能用于基本数据类型；
								 ==在引用类型中，用于比较两个对象的内存地址值是否相等； equals方法：在没有重写Object类中的equals方法的时候，比较的是哈希值，
								 如果重写了equals方法，则是按照重写的规则来比较。

			String类：
						1.final修饰，不能被继承；
						2.为了提高效率，字符串对象被保存在常量池中。

						String str="hello";       // 代码1
						String str=new String("hello");   // 代码2

						问：代码1和代码2分别会在内存中创建几个对象？
						     在字符串常量池中有“hello”时：
							   代码 1    直接将String constant pool中的hello拿过来使用
							   代码 2  需要创建一个对象 需要在编译期使用new创建一个对象 然后指向String constant pool中的“hello”
						  在String constant pool中没用“hello”时
							    代码 1 需要自己创建一个“hello”放在String constant pool中  在执行一次String constant pool中没有的步骤
							    代码 2 同上。
                             反射和枚举
			     集合     
			                Collection：集合的索引从一 开始   有迭代器iterator()
					                 List (有序可重复)：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，
							                                 因为会引起其他元素位置改变 list特有迭代器 listIterator()方法
							             ArrayList：底层使用数组
								     linkedList：底层使用链表
							             vector：一种老的动态数组是线程同步的 基于ArrayList  效率低 一般不建议使用
							 
							 set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
							        HashSet：以哈希表的形式存放元素，插入删除速度很快
								TreeSet：二叉树排序，升序排列

					Map:       
					         hashmap：
						 TreeSet：
			     IO流
			     线程
			     异常处理机制
			     网络编程
			               服务器：
				       客户端：
				       多线程服务器：
	                     
	XML：
	            书写的基本要求   所起到的作用
		    约束和解析（两种约束，三种解析）
	
	
	
	数据库相关（Oracle）：
	                 sql语句（五种分类   ACID四种特性  视图的作用 等等 ）
                         
					 五大分类：
							 DDL：数据定义语言    create     drop    alter     truncate   rename
							 DML：数据操纵语言   intest      delete   update   
							 DQL：数据查询语言    select
							 DCL：权限控制语言    revoke   grant
							 TCL：事务管理              commit      rollback    savepoint
 

				       ACID(四种特性)：
							原子性(Atomicity )：  事务是一个独立的单元  要吗成功 要么不成功
							一致性(Consistency)：   事务必须和系统处于一致的状态（不一直会导致其他系统出现BUG）
							隔离性(Isolation)：    事务是并发控制机制他们也需要一致性 隔离隐藏，一般通过悲观
											    或者乐观锁实现
							持久性(Durability)：一个成功的事务应该永久的改变系统的状态 所以在它结束之前 所有导致的状态
											都应该记录在一个持久事务日志中

                       视图的作用：
					        1.简化操作   把经常使用的数据定义成视图
							2.安全性  用户只能查询和修改可见的数据
							3.逻辑的独立性  屏蔽了真实的表结构所带来的影响

				                        创建视图  一张或多张表[原始数据|加工数据]的映射
													create view 视图名
													as
													select语句；
									查询 修改  删除  和插入视图和操作表相同  指示操作范围为可见数据
					sql优化：
								索引：
									创建索引：
											create index 索引名
											on 表名(列名);

											创建索引：  create index 索引名   on    表名(列名)
									例如：
											create index emp_index
											on s_emp(last_name);
						
									删除索引:
										drop index 索引名;

										删除索引 ： drop index 索引名
									例如:
										drop index emp_index;

									创建成功后可以通过【数据字典】查看：
										select index_name from user_indexes;
										select index_name from user_indexes; 
					        
					3.给某列创建索引的原则（了解）
							索引的最大优势是 提高效率。
							a.列经常作为where子句的限定条件或者作为连接条件
							b.列包含的数据量很大，并且很多非空的值。
							c.两个或者更多列频繁的组合在一起作为where的限定条件或者连接条件
							d.列总是作为搜索条件
							e.索引查出的数据量占总数据量的2%~4%
							f.索引不是越多越好，不是索引越多越能加速查找。
							g.要建立索引的表不经常进行修改操作


				
						                    
 
			 JDBC技术：
			               
                                      Driver(驱动类全名)：oracle.jdbc.OracleDriver

			              URL：统一资源定位符  jdbc:oracle:thin:@127.0.0.1:1521:XE
				      URI： 统一资源标识符
			               六大步（当执行sql语句为查询语句时 会产生结果集    除此之外为五步）：
				                                      1，注册驱动
								      2，获取连接   connection对象  
								                 1.DriverManager调用静态方法：
											1.getConnection(url);		// 不适用于Oracle数据库
											2.getConnection(url,info);
											3.getConnection(url,user,password);    常用
										2.使用相关驱动类的对象调用方法：
											Driver driver=new OracleDriver();
											driver.connect(url,info);

								      3，获取statement对象
								      4，执行sql语句
								      5，处理结果集
								      6，关闭连接
				       注册驱动的三种方式：
				                                    类加载方式创建连接：Class.forName("驱动类全名");
								    直接创建相关驱动类对象：Driver driver=new OracleDriver();
								    通过系统属性配置的形式：System.setProperty("jdbc.drivers","驱动类全名");
								                     
				      Statement和PreparedStatement：
									PreparedStatement：能够进行SQL语句的批处理操作和防止SQL注入攻击。
									区别：
										1.PreparedStatement比Statement安全；
										2.PreparedStatement比Statement效率高；
										3.PreparedStatement的代码可读性较强。
				  注意：
							1.在Java中有两种Date:
								1.java.util.Date：主要用于Java编程。
								2.java.sql.Date：主要用于数据库。

							2.两种Date的转换：
								1.uDate->sDate
									java.util.Date uDate=new j.u.Date();

									Long time=uDate.getTime();

									j.s.Date sDate=new j.s.Date(time);

								2.sDate->uDate
									j.s.Date sDate=new j.s.Date(10);

									Long time=sDate.getTime();

									j.u.Date uDate=new j.u.Date(time);

							3.将一个格式的时间字符串转化成Date对象；
								"1990-01-01"->j.u.Date

								SimpleDateFormat
				JDBC中的事务：
							0.JDBC中的事务是通过Connection对象控制的；
							1.JDBC中的事务默认是自动提交的；
							2.如果需要手动提交事务，则需要将默认的事务提交方式（自动提交）关闭，
							    connection.setAutoCommit(false);
							3.当执行connection.close()操作的时候，默认会提交事务。
							4.为了保证事务的原子性，在发生异常的时候需要事务回滚，connection.rollback();

     web前段项目：
                           servlet：
			              创建servlet的三种方式
				      servlet的生命周期：
				                     第一次访问网页创建servlet对象
								     调用init方法进行初始化
								     在之后 每发送一次访问都不会再创建servlet对象
								     servlet对象每一次调用service方法   之后层层调用 我们重写的doGet()  doPost() 方法
								     servlet在销毁时调用destroy方法
		           过滤器监听器：
			   HTML：  
			   JSP：
     框架：
               myBatis：
	       Spring：
	             IOC（控制反转  依赖注入）：
		                                               Bean的生命周期：     
							                     读取配置文件时创建  (通过lazy-init=true延迟加载属性将对象的创建  延迟
											     到程序员调用getBean()方法之后 )通过无参构造器和初始化方法确认
											     容器在ClassPathXmlApplicationContext调用destroy方法时销毁  对象销毁
											     单例模式由Spring容器管理  负责创建和销毁
											     多例模式由程序员管理   Spring没有管理权限
							      ioc 几种注入方式：
											       1.set注入方式（bean需要拥有set方法 property标签中name属性值
											                                  为set后单词首字母小写）
											       2.构造器注入（需要将属性补全）
											       3.集合注入
											       4.自动注入
		                                                      
		     AOP（面向切面编程）：
		                 专业名词：   aspect    切面/切面类
				                       
						       joinPoint：  连接点
                                                                            只有Spring中aop类中的方法才能被称为是连接点   每一个方法都是一个连接点						      

						       pointCut：切入点    一组连接点的集合

						       advice：通知/拦截器
						                     用来控制切面类将来是织入到切入点的前面还是切入点的后面   或者是在发生异常的时候
								  
                                                      advisor：增强器
						                      用来筛选那些方法是我们的连接点  （需要拦截哪些方法）

						      target：目标对象
						                   需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可
								   称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象；
								   在AOP中表示为“对谁干”；

						      proxy：代理对象
						                    AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过
								    代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，
								    而通过拦截器模型应用切面。

						      wave：织入
						                  织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、
								  类装载期、运行期进行。组装方面来创建一个被通知对象。这可以在编译时完成
								  （例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在
								  运行时完成织入。
                                 advice(通知/拦截器)
						  前置通知（Before advice）： 
							在某连接点（join point）之前执行的通知

						返回后通知（After returning advice）： 
							在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，
							正常返回。

						抛出异常后通知（After throwing advice）： 
							在方法抛出异常退出时执行的通知。

						后通知（After (finally) advice）： 
							当某连接点退出的时候执行的通知

						环绕通知（Around Advice）： 
							包围一个连接点（join point）的通知，例如事务的处理,就需要这样的通知,因为事务需要
							在方法前开启,在方法后提交
				代理：
				      静态代理类：
					    由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
				      动态代理类：在程序运行时，运用反射机制动态创建而成。
                                      
                                     静态代理：创建一个公共的接口      代理类和目标类一起继承公共接口 在代理类中加入成员变量(接口类型)
				                        在代理类中与目标类对应的方法中执行目标类的方法 将需要添加的功能添加在代理类方法中 
							保证了目标类方法不被修改  提高了代码的复用性

				      两种动态代理：
				                    JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对
						                             目标对象的代理。
						    CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。
						                         CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实
									 现的。
				使用自动代理的时候需要注意的方面:
							1.当前的配置里面一定要有一个advisor的配置
							2.不需要向自动代理类中注入任何信息
							3.不管目标对象是否实现了一个或多接口,自动代理的方式
							  都能够为它产生代理对象(CGLib的方式).
							4.从spring容器中拿代理对象的时候,需要通过目标对象的
							  名字来拿。
							5.spring如何确定配置文件中哪个bean是作为目标对象:
								  通过advisor中筛选的方法,如果这个bean中含有advisor中所配置的方法,则这个bean将来称为我们的目标对象进行代理
												       
				                  
		     MVC（和web项目结合）





              软件应用分层架构
						标准三层架构：
						1：数据访问层：主要是对原始数据（数据库或者文本文件等存放数据的形式）的操作层，而不是指原始数据，也就是
									     说，是对数据的操作，而不是数据库，具体为业务逻辑层或表示层提供数据服务．
						2：业务逻辑层：主要是针对具体的问题的操作，也可以理解成对数据层的操作，对数据业务逻辑处理，如果说数据层
									     是积木，那逻辑层就是对这些积木的搭建。具体的讲主要负责对数据层的操作。也就是说把一些数据
									     层的操作进行组合。
						3：表示层：主要表示WEB方式，如果逻辑层相当强大和完善，无论表现层如何定义和更改，逻辑层都能完善地提供服
								     务。主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。

					优点:
						1：开发人员可以只关注整个结构中的其中某一层；
						2：可以很容易的用新的实现来替换原有层次的实现；
						3：可以降低层与层之间的依赖；
						4：有利于标准化；
						5：利于各层逻辑的复用。
						6：结构更加的明确
						7：在后期维护的时候，极大地降低了维护成本和维护时间
					缺点:
						1：降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。
						2：有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。
						3：增加了开发成本。
									       

								      
