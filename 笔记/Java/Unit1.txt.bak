JavaSE：Standard Edition，标准版
	Core Java，核心Java

Java之父：James Gosling，高司令

Java编程基础：
第一章：
	目标：
	1.设置Java开发环境
	2.理解Java的特点
	3.理解Java虚拟机（JVM，Java Virtual Machine）的功能
	4.理解Java垃圾回收机制，Garbage Collection，GC，垃圾回收器
	5.理解Java对于代码安全性验证的方法
	6.学会定义类，包，Java应用程序
	7.学会编写Java代码，编译Java代码，执行Java代码。

1.设置Java开发环境
	a.下载Java开发软件包。
		JDK：Java Development Kit，Java开发工具集
		JRE：Java Run Environment，Java运行环境

		JDK中已经包含了JRE，但是JRE可以单独安装。

	b.设置环境变量：
		Linux：
			> vi ~/.bashrc

				export JAVA_HOME=/opt/links/jdk
				export JRE_HOME=$JAVA_HOME/jre
				export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib
				export PATH=$PATH:$JAVA_HOME/bin

			> source ~/.bashrc
			> java 
			> javac
			> java -version
			> javac -version

		Windows：

2.Java的特点：
	Write Once, Run Anywhere.
	一处编译，导出运行。

	Pure Object-Oriented，纯面向对象

3.JVM，Java Virtual Machine，Java虚拟机。
	C语言，
		Code(.c) --> Translate(.obj/.out/.o) --> Compile(.exe) --> Execute
	
	Java语言：
		Code(.java) --> Compile(.class) --> Run(在JVM中运行)

	.java：源代码
	.class：字节码

	运行Java程序的JVM实际上是操作系统中的一个进程，也称之为：JVM进程或者Java虚拟机进程。

4.Garbage Collection：GC，垃圾回收器
	a.回收JVM中的已经不再使用的对象（数据）。
	b.GC是JVM进程中的一个线程，随时在执行这个垃圾回收器。
	c.垃圾回收也可以在代码中人为指定。

5.代码安全性验证及Java程序在JVM中的运行过程：
	a.ClassLoader，类加载：将编译生成的.class文件加载到JVM中。
		Bootstrap ClassLoader，启动类（根类）加载：
		$JRE_HOME/lib/*.jar
	Extended ClassLoader，外部类加载：
		$JRE_HOME/lib/ext/*jar
	Application ClassLoader，应用程序类加载：
		$CLASSPATH/*.jar   （CLASSPATH所标示的所有路径）
		
		export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib

	User-Defined ClassLoader，用户自定义类加载：
	Network ClassLoader：网络类加载：

双亲委托机制：
	向上委托，向下加载。

	在运行一个类的时候，先触发应用程序类加载器，但是此时该类加载器不会直接加载要运行的类，
	而是向上委托给外部类加载器去加载该要运行的类，但是外部类加载器也不会直接加载该类，
	而是继续向上委托给启动类加载器，让启动类加载器去加载要执行的类：
	     1.如果启动类加载器能在自己的加载路径中找到要运行的类，则直接运行。
	     2.如果启动类加载器在自己的加载路径中找不到要运行的类，此时，启动类加载器会让外部类加载器来加载。
		*外部类加载的加载方式和启动类加载器的加载方式一致。
		*应用程序类加载器：如果找到该类，直接运行；如果没有找到该类，报错：“无法找到或加载主类 Xxx”；



	b.ByteCode Verifier：字节码验证。
		1.验证字节码和JVM是否兼容。
			HelloWorl.java
			编译：JDK1.7    运行：JDK1.7+
	
		2.验证代码是否可以破坏系统的完整性。
		3.检测代码中是否有存在是内存栈溢出的代码。
		4.检测代码中参数的类型是否正确。
		5.检测类型转换是否正确。

Java程序的运行过程：
	1.通过javac编译生成字节码文件（.class）
	2.通过java命令运行该字节码文件中的类；一个类能够运行的条件是该类中必须包含程序的运行入口方法：
		public static void main(String[] args){}
执行模式 ：即时执行     翻译执行

例	
> vi Test1.java
		
		class HelloBriup{
			public static void main(String[] args){
				System.out.println("Hello Briup!!!");
			}
		}

	> javac Test1.java
		
		HelloBriup.class

	> java HelloBriup

Java代码的编写规则：
	1.当Java代码中的一个类使用public修饰的时候，则该Java文件的文件名应和该类的类名一致。
	2.在一个Java文件中，只能有一个使用public修饰的类。
	3.在一个Java文件中，编写N个class，通过javac编译之后就会生成N个.class文件，
	        每个.class文件的文件名就是Java文件class关键字后面的类名。
	Test2.java
	class Abc{}  ---->  Abc.class
	class Xyz{}  ---->  Xyz.class

ava命令运行类的流程：
	> java Abc

	1.给Abc添加“.class”后缀，然后在“各种”路径中寻找“Abc.class”这个字节码文件是否存在。
	2.如果不存在，则报错-->"错误: 找不到或无法加载主类 Abc"
	3.如果存在，将该字节码文件加载到JVM中，然后在JVM中的该字节码文件中寻找“main”方法来执行。 
		a.如果存在主方法，运行成功。
		b.如果不存在主方法，报错-->"在类Abc中找不到main方法，请。。。"

package sample;                               //package declaration

import java.util.Date;                          //import statements

public class HelloWorld extends Object{             //class declaration
	public static void main(String[] args) {         //execution entry
		System.out.println(new Date()+“:Hello World!”);
	}
}


Java中的一些基本概念：
	Source File，源文件：
		1.一个Java文件中只能有一个public修饰的类，而且该类名和Java文件名相同。
		2.一个Java文件没有public修饰的类，该Java文件的文件名随意。

	Package，包：
		1.就是用来解决相同类名在同一目录下的存储问题。
		2.对于开发大型项目，包也是用来区分不同模块的。
		3.在一般情况下，包名的定义如下：公司域名倒写+模块名称。
			com.briup.abc

	Class，类：
		在Java中，类指的是对于具有相同属性和相同行为的这一类事物的统称。

	Function，方法：
		在Java中，方法指的是类的实例的行为。

	Field，成员变量：
		在Java中，成员变量指的是类的属性。


Java程序的运行：
	1.编写.java文件			vi Hello.java
	2.编译生成.class文件	javac Hello.java --> Hello.class
	3.运行.class文件		java Hello

Java中一些比较重要的命令：
	javac [-d path] *.java
    javac Cd 打包地址 *.java
   例  Javac Cd . abc.Java

	java Xxx

	jar -cvf abc.jar Abc.class		-->		abc.jar

	运行jar包中的类或打包成jar：
	java -cp abc.jar Abc
    java Ccp .(打包路径) com.briup.md01.test1(全包类名)


	export CLASSPATH=$CLASSPATH:abc.jar