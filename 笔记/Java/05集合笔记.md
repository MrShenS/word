邵永波
shaoyb@briup.com


###15.01_集合框架(对象数组的概述和使用)
* A:案例演示
	* 需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。
* 
		Student[] arr = new Student[5];					//存储学生对象
		arr[0] = new Student("张三", 23);
		arr[1] = new Student("李四", 24);
		arr[2] = new Student("王五", 25);
		arr[3] = new Student("赵六", 26);
		arr[4] = new Student("马哥", 20);
		
		for (int i = 0; i < arr.length; i++) {
			System.out.println(arr[i]);
		}
		
* B:画图演示
	* 把学生数组的案例画图讲解
	* 数组和集合存储引用数据类型,存的都是地址值

###15.02_集合框架(集合的由来及集合继承体系图)
* A:集合的由来
	* 数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少.
* B:数组和集合的区别
	* 区别1 : 
		* 数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值
		* 集合只能存储引用数据类型(对象),集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象
	* 区别2:
		* 数组长度是固定的,不能自动增长
		* 集合的长度的是可变的,可以根据元素的增加而增长
* C:数组和集合什么时候用
	* 1,如果元素个数是固定的推荐用数组
	* 2,如果元素个数不是固定的推荐用集合
* D:集合继承体系图
	* 单列集合 顶层接口Collection
	* 实现子类 List有序、重复				Set无序、不能重复
	* ArrayList LinkedList Vector 		HashSet哈希算法   TreeSet二叉树算法

###15.03_集合框架(Collection集合的基本功能测试)
* A:案例演示	
* 
		基本功能演示
		
		boolean add(E e)
		boolean remove(Object o)
		void clear()
		boolean contains(Object o)
		boolean isEmpty()
		int size()

* B:注意:
* 
		collectionXxx.java使用了未经检查或不安全的操作.
		注意:要了解详细信息,请使用 -Xlint:unchecked重新编译.
		java编译器认为该程序存在安全隐患
		温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了
	  
###15.04_集合框架(集合的遍历之集合转数组遍历)
* A:集合的遍历
	* 其实就是依次获取集合中的每一个元素。
* B:案例演示
	* 把集合转成数组，可以实现集合的遍历
	* toArray()
	*
		
			Collection coll = new ArrayList();
			coll.add(new Student("张三",23));		//Object obj = new Student("张三",23);
			coll.add(new Student("李四",24));
			coll.add(new Student("王五",25));
			coll.add(new Student("赵六",26));
			
			Object[] arr = coll.toArray();				//将集合转换成数组
			for (int i = 0; i < arr.length; i++) {
				Student s = (Student)arr[i];			//强转成Student
				System.out.println(s.getName() + "," + s.getAge());
			}

###15.05_集合框架(Collection集合的带All功能测试)
* A:案例演示
* 
		带All的功能演示
		
		boolean addAll(Collection c)
		boolean removeAll(Collection c)
		boolean containsAll(Collection c)
		boolean retainAll(Collection c)		取交集，如果集合内容改变则返回true,否则返回false


###15.06_集合框架(集合的遍历之迭代器遍历)
* A:迭代器概述
	* 集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) 
* B:案例演示
	* 迭代器的使用
		
			Collection c = new ArrayList();
			c.add("a");
			c.add("b");
			c.add("c");
			c.add("d");
			
			Iterator it = c.iterator();						//获取迭代器的引用
			while(it.hasNext()) {							//集合中的迭代方法(遍历)
				System.out.println(it.next());
			}
	
			
###15.07_集合框架(Collection存储自定义对象并遍历)
* A:案例演示
	* Collection存储自定义对象并用迭代器遍历
	* 
			Collection c = new ArrayList();
			
			c.add(new Student("张三",23));
			c.add(new Student("李四",24));
			c.add(new Student("王五",25));
			c.add(new Student("赵六",26));
			c.add(new Student("赵六",26));
			
			for(Iterator it = c.iterator();it.hasNext();) {
				Student s = (Student)it.next();						//向下转型
				System.out.println(s.getName() + "," + s.getAge());	//获取对象中的姓名和年龄
			}
			System.out.println("------------------------------");
			Iterator it = c.iterator();								//获取迭代器
			while(it.hasNext()) {									//判断集合中是否有元素
				//System.out.println(((Student)(it.next())).getName() + "," + ((Student)(it.next())).getAge());
				Student s = (Student)it.next();						//向下转型
				System.out.println(s.getName() + "," + s.getAge());	//获取对象中的姓名和年龄
			}
		

###15.08_集合框架(迭代器的原理及源码解析)(了解)
* A:迭代器原理
	* 迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 
* B:迭代器源码解析
	* 1,在eclipse中ctrl + shift + t找到ArrayList类
	* 2,ctrl+o查找iterator()方法
	* 3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口
	* 4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 

###15.09_集合框架(List集合的特有功能概述和测试)
* A:List集合的特有功能概述
	* void add(int index,E element)
	* E remove(int index)
	* E get(int index)
	* E set(int index,E element)

###15.10_集合框架(List集合存储学生对象并遍历)
* A:案例演示
	* 通过size()和get()方法结合使用遍历。

			List list = new ArrayList();
			list.add(new Student("张三", 18));
			list.add(new Student("李四", 18));
			list.add(new Student("王五", 18));
			list.add(new Student("赵六", 18));
			
			for(int i = 0; i < list.size(); i++) {
				Student s = (Student)list.get(i);
				System.out.println(s.getName() + "," + s.getAge());
			}

###15.11_集合框架(并发修改异常产生的原因及解决方案)
* A:案例演示
	* 需求：我有一个集合，请问，我想判断里面有没有"world"这个元素，如果有，我就添加一个"javaee"元素，请写代码实现。

			List list = new ArrayList();
			list.add("a");
			list.add("b");
			list.add("world");
			list.add("d");
			list.add("e");
			
			/*Iterator it = list.iterator();
			while(it.hasNext()) {
				String str = (String)it.next();
				if(str.equals("world")) {
					list.add("javaee");			//这里会抛出ConcurrentModificationException并发修改异常
				}
			}*/
			
			
* B:ConcurrentModificationException出现
	* 迭代器遍历，集合名 修改集合内部值
* C:解决方案
	* a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add)
	* b:集合遍历元素，集合修改元素

			ListIterator lit = list.listIterator();		//如果想在遍历的过程中添加元素,可以用ListIterator中的add方法
			while(lit.hasNext()) {
				String str = (String)lit.next();
				if(str.equals("world")) {
					lit.add("javaee");	
					//list.add("javaee");
				}
			}

###15.12_集合框架(ListIterator)(了解)
* boolean hasNext()是否有下一个
* boolean hasPrevious()是否有前一个
* Object next()返回下一个元素
* Object previous();返回上一个元素

###15.13_集合框架(Vector的特有功能)
* A:Vector类概述
* B:Vector类特有功能
	* public void addElement(E obj)
	* public E elementAt(int index)
	* public Enumeration elements()
* C:案例演示	
	* Vector的迭代

			Vector v = new Vector();				//创建集合对象,List的子类
			v.addElement("a");
			v.addElement("b");
			v.addElement("c");
			v.addElement("d");
			
			//Vector迭代
			Enumeration en = v.elements();			//获取枚举
			while(en.hasMoreElements()) {			//判断集合中是否有元素
				System.out.println(en.nextElement());//获取集合中的元素
			}

###15.14_集合框架(数据结构之数组和链表)
* A:数组
	* 查询快修改也快
	* 增删慢
* B:链表
	* 查询慢,修改也慢
	* 增删快

###15.15_集合框架(List的三个子类的特点)
* A:List的三个子类的特点
* 
		ArrayList:
			底层数据结构是数组，查询快，增删慢。
			线程不安全，效率高。
		Vector:
			底层数据结构是数组，查询快，增删慢。
			线程安全，效率低。

		Vector相对ArrayList查询慢(线程安全的)
		Vector相对LinkedList增删慢(数组结构)
		LinkedList:
			底层数据结构是链表，查询慢，增删快。
			线程不安全，效率高。

		Vector和ArrayList的区别
			Vector是线程安全的,效率低
			ArrayList是线程不安全的,效率高
		共同点:都是数组实现的
		ArrayList和LinkedList的区别
			ArrayList底层是数组结果,查询和修改快
			LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢
		共同点:都是线程不安全的
* B:List有三个儿子，我们到底使用谁呢?
		查询多用ArrayList
		增删多用LinkedList
		如果都多ArrayList

* ****************************
###16.01_集合框架(去除ArrayList中重复字符串元素方式)(掌握)
* A:案例演示
	* 需求：ArrayList去除集合中字符串的重复值(字符串的内容相同)
	* 思路：创建新集合方式

			/**
			 *  A:案例演示
			 * 需求：ArrayList去除集合中字符串的重复值(字符串的内容相同)
			 * 思路：创建新集合方式
			 */
			public static void main(String[] args) {
				ArrayList list = new ArrayList();
				list.add("a");
				list.add("a");
				list.add("b");
				list.add("b");
				list.add("b");
				list.add("c");
				list.add("c");
				list.add("c");
				list.add("c");
				
				System.out.println(list);
				ArrayList newList = getSingle(list);
				System.out.println(newList);
			}
		
			/*
			 * 去除重复
			 * 1,返回ArrayList
			 * 2,参数列表ArrayList
			 */
			public static ArrayList getSingle(ArrayList list) {
				ArrayList newList = new ArrayList();			//创建一个新集合
				Iterator it = list.iterator();					//获取迭代器
				while(it.hasNext()) {							//判断老集合中是否有元素
					String temp = (String)it.next();			//将每一个元素临时记录住
					if(!newList.contains(temp)) {				//如果新集合中不包含该元素
						newList.add(temp);						//将该元素添加到新集合中
					}
				}
				return newList;									//将新集合返回
			}
###16.02_集合框架(去除ArrayList中重复自定义对象元素)(掌握)
* A:案例演示
	* 需求：ArrayList去除集合中自定义对象元素的重复值(对象的成员变量值相同)
* B:注意事项
	* 重写equals()方法的

###16.03_集合框架(LinkedList的特有功能)(掌握)
* A:LinkedList类概述
* B:LinkedList类特有功能
	* public void addFirst(E e)及addLast(E e)
	* public E getFirst()及getLast()
	* public E removeFirst()及public E removeLast()
	* public E get(int index);
* C: 利用特有方法添加成员到 集合中，然后遍历； 然后再删除头尾，再次遍历。

###16.04_集合框架(栈和队列数据结构)(掌握)
* 栈
	* 先进后出 
* 队列
	* 先进先出

###16.05_集合框架(用LinkedList模拟栈数据结构的集合并测试)(掌握)
* A:案例演示
	* 需求：请用LinkedList模拟栈数据结构的集合，并测试
	* 创建一个类将Linked中的方法封装
	* 
			public class Stack {
				private LinkedList list = new LinkedList();		//创建LinkedList对象
				
				public void in(Object obj) {
					list.addLast(obj);							//封装addLast()方法
				}
				
				public Object out() {
					return list.removeLast();					//封装removeLast()方法
				}
				
				public boolean isEmpty() {
					return list.isEmpty();						//封装isEmpty()方法
				}
			}
	
###16.06_集合框架(泛型概述和基本使用)(掌握)
* A:泛型概述
	* 不确定的类型  什么都可以的意思。
* B:泛型好处
	* 提高安全性【将运行期的错误转换到编译期】 
	* 省去强转的麻烦
* C:泛型基本使用
	* <>中放的必须是引用数据类型 
* D:泛型使用注意事项
	* 前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型)  

###16.07_集合框架(ArrayList存储字符串和自定义对象并遍历泛型版)(掌握)
* A:案例演示
	* ArrayList存储字符串并遍历泛型版

###16.08_集合框架(泛型的由来)(了解)
* A:案例演示
	* 泛型的由来:通过Object转型问题引入
	* 早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。

###16.09_集合框架(泛型类的概述及使用)(了解)
* A:泛型类概述<T> 
	* 把泛型定义在类上
* B:定义格式
	* public class 类名<泛型类型1,…>
* C:注意事项	
	* 泛型类型必须是引用类型
* D:案例演示
	* 泛型类的使用

###16.10_集合框架(泛型方法的概述和使用)(了解)
* A:泛型方法概述
	* 把泛型定义在方法上
* B:定义格式	
	* public<泛型类型> 返回类型 方法名(泛型类型 变量名)
	* 最好与类泛型一致
* C:案例演示
	* 泛型方法的使用
* D:静态方法中，必须声明自己的泛型
	* 静态方法不依赖对象,而类泛型只有在创建对象时传递类型值。 

###16.11_集合框架(泛型接口的概述和使用)(了解)
* A:泛型接口概述
	* 把泛型定义在接口上
* B:定义格式	
	* public interface 接口名<泛型类型>
	* a. 实现类中确定类型
	* b. class Demo<T> implements 接口<T> { ... } 
* C:案例演示
	* 泛型接口的使用

###16.12_集合框架(泛型高级之通配符)(了解)
* A:泛型通配符<?>
	* 任意类型，如果没有明确，那么就是Object以及任意的Java类了
* B:? extends E
	* 向下限定，E及其子类
	* addAll(Collection<? extends E>);
* C:? super E
	* 向上限定，E及其父类

###16.13_集合框架(增强for的概述和使用)(掌握)
* A:增强for概述
	* 简化数组和Collection集合的遍历
	* 底层是通过迭代器实现的。
* B:格式：
* 
		for(元素数据类型 变量 : 数组或者Collection集合) {
			使用变量即可，该变量就是元素
		}
* C:案例演示
	* 数组，集合存储元素用增强for遍历
* D:好处
	* 简化遍历

###16.14_集合框架(ArrayList存储字符串和自定义对象并遍历增强for版)(掌握)
* A:案例演示
	* ArrayList存储字符串并遍历增强for版
	* 
			ArrayList<String> list = new ArrayList<>();
			list.add("a");
			list.add("b");
			list.add("c");
			list.add("d");
			
			for(String s : list) {
				System.out.println(s);
			}
		底层借助迭代器实现.

###16.15_集合框架(三种迭代的能否删除)(掌握)
* 普通for循环,可以删除,但是【索引要--】
* 迭代器,可以删除,但是必须使用迭代器自身的remove方法,否则会出现并发修改异常
* 增强for循环不能删除【底层通过迭代器实现，不能删除】

###16.16_集合框架(静态导入的概述和使用)(掌握)
* A:静态导入概述
* B:格式：
	* import static 包名….类名.方法名;
	* 可以直接导入到方法的级别
* C:注意事项
	* 方法必须是静态的,如果有同名的方法，就不知道使用谁?这个时候要使用，必须加前缀。由此可见，意义不大，所以一般不用，但是要能看懂。

###16.17_集合框架(可变参数的概述和使用)(掌握)
* A:可变参数概述
	* 定义方法的时候不知道该定义多少个参数
* B:格式
	* 修饰符 返回值类型 方法名(数据类型…  变量名){}
* C:注意事项：
	* 这里可变参数 其实 是一个数组
	* 如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个

###16.18_集合框架(Arrays工具类的asList()方法的使用)(掌握)
* A:案例演示
	* Arrays工具类的asList()方法的使用
	* 将数组转换成集合
	* 
	* 注意：转换成集合后，不可以增加或减少元素，但可以用集合思想操作数据。
	*      如果操作标准数据类型数组，则将数组当成一个元素添加到数组中。
	
	* Collection中toArray(T[] a)泛型版的集合转数组
	* 例如 list.toArray(new String[n]); n值不同，转换得到的数组不同

###16.19_集合框架(集合嵌套之ArrayList嵌套ArrayList)(掌握)
* A:案例演示
	* 集合嵌套之ArrayList嵌套ArrayList
	* 专业中包含多个班级，每个班级包含多个学生 

* *****************************
###17.01_集合框架(HashSet存储字符串并遍历)
* A:Set集合概述及特点
	* 通过API查看即可
* B:案例演示
	* HashSet存储字符串并遍历
	* 
		 	HashSet<String> hs = new HashSet<>();
			boolean b1 = hs.add("a");
			boolean b2 = hs.add("a");			//当存储不成功的时候,返回false
			
			System.out.println(b1);
			System.out.println(b2);
			for(String s : hs) {
				System.out.println(s);
			}

###17.02_集合框架(HashSet存储自定义对象保证元素唯一性)
* A:案例演示
	* 存储自定义对象，并保证元素唯一性。

			HashSet<Person> hs = new HashSet<>();
			hs.add(new Person("张三", 23));
			hs.add(new Person("张三", 23));
			hs.add(new Person("李四", 23));
			hs.add(new Person("李四", 23));
			hs.add(new Person("王五", 23));
			hs.add(new Person("赵六", 23));
* 重写hashCode()和equals()方法

###17.03_集合框架(HashSet存储自定义对象保证元素唯一性图解及代码优化)
* A:画图演示
	* 画图说明比较过程
* B:代码优化
	* 为了减少比较，优化hashCode()代码写法。
	* 最终版就是自动生成即可。

###17.04_集合框架(HashSet如何保证元素唯一性的原理)
* 1.HashSet原理
	* 我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数
	* 当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象
		* 如果没有哈希值相同的对象就直接存入集合
		* 如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存
* 2.将自定义类的对象存入HashSet去重复
	* 类中必须重写hashCode()和equals()方法
	* hashCode(): 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率)
	* equals(): 属性相同返回true, 属性不同返回false,返回false的时候存储

###17.05_集合框架(LinkedHashSet的概述和使用)
* A:LinkedHashSet的特点
* B:案例演示
	* LinkedHashSet的特点
		* 可以保证怎么存就怎么取 

###17.06_集合框架(产生10个1-20之间的随机数要求随机数不能重复)
* A:案例演示
	* 需求：编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。
	* 
			HashSet<Integer> hs = new HashSet<>();		//创建集合对象
			Random r = new Random();					//创建随机数对象
			
			while(hs.size() < 10) {
				int num = r.nextInt(20) + 1;			//生成1到20的随机数
				hs.add(num);
			}
			
			for (Integer integer : hs) {				//遍历集合
				System.out.println(integer);			//打印每一个元素
			}

###17.07_集合框架(练习)
* 使用Scanner从键盘读取一行输入,去掉其中重复字符, 打印出不同的那些字符
	* aaaabbbcccddd

			Scanner sc = new Scanner(System.in);			//创建键盘录入对象
			System.out.println("请输入一行字符串:");
			String line = sc.nextLine();					//将键盘录入的字符串存储在line中
			char[] arr = line.toCharArray();				//将字符串转换成字符数组
			HashSet<Character> hs = new HashSet<>();		//创建HashSet集合对象
			
			for(char c : arr) {								//遍历字符数组
				hs.add(c);									//将字符数组中的字符添加到集合中
			}
			
			for (Character ch : hs) {						//遍历集合
				System.out.println(ch);
			}

###17.08_集合框架(练习)
* 将ArrayList集合中的重复元素去掉
* 
			public static void main(String[] args) {
				ArrayList<String> list = new ArrayList<>();
				list.add("a");
				list.add("a");
				list.add("a");
				list.add("b");
				list.add("b");
				list.add("b");
				list.add("b");
				list.add("c");
				list.add("c");
				list.add("c");
				list.add("c");
				
				System.out.println(list);
				System.out.println("去除重复后:");
				getSingle(list);
				System.out.println(list);
			}
			
			/*
			 * 将集合中的重复元素去掉
			 * 1,void
			 * 2,List<String> list
			 */
			
			public static void getSingle(List<String> list) {
				LinkedHashSet<String> lhs = new LinkedHashSet<>();
				lhs.addAll(list);									//将list集合中的所有元素添加到lhs
				list.clear();										//清空原集合
				list.addAll(lhs);									//将去除重复的元素添回到list中
			}

###17.09_集合框架(TreeSet存储Integer类型的元素并遍历)
* A:案例演示
	* TreeSet存储Integer类型的元素并遍历

###17.10_集合框架(TreeSet存储自定义对象)
* A:案例演示
	* 存储Person对象

###17.11_集合框架(TreeSet保证元素唯一和自然排序的原理和图解)
* A:画图演示
	* TreeSet保证元素唯一和自然排序的原理和图解

###17.12_集合框架(TreeSet存储自定义对象并遍历练习1)
* A:案例演示
	* TreeSet存储自定义对象并遍历练习1(按照姓名排序)

###17.13_集合框架(TreeSet存储自定义对象并遍历练习2)
* A:案例演示
	* TreeSet存储自定义对象并遍历练习2(按照姓名的长度排序)
	* compareTo(Person p) {
	* 	int num = name.length() - p.name.length();
	* 	return num;
	* }

###17.14_集合框架(TreeSet保证元素唯一和比较器排序的原理及代码实现)
* A:案例演示
	* TreeSet保证元素唯一和比较器排序的原理及代码实现

###17.15_集合框架(TreeSet原理)
* 1.特点
	* TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列
* 2.使用方式
	* a.自然顺序(Comparable)
		* TreeSet类的add()方法中会把存入的对象提升为Comparable类型
		* 调用对象的compareTo()方法和集合中的对象比较
		* 根据compareTo()方法返回的结果进行存储
	* b.比较器顺序(Comparator)
		* 创建TreeSet的时候可以制定 一个Comparator
		* 如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序
		* add()方法内部会自动调用Comparator接口中compare()方法排序
		* 调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数
	* c.两种方式的区别
		* TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException)
		* TreeSet如果传入Comparator, 就优先按照Comparator

###17.16_集合框架(练习)
* 在一个集合中存储了无序并且重复的字符串,定义一个方法,让其有序(字典顺序),而且还不能去除重复

			public static void main(String[] args) {
				ArrayList<String> list = new ArrayList<>();
				list.add("ccc");
				list.add("ccc");
				list.add("aaa");
				list.add("aaa");
				list.add("bbb");
				list.add("ddd");
				list.add("ddd");
				
				sort(list);
				System.out.println(list);
			}
			
			/*
			 * 对集合中的元素排序,并保留重复
			 * 1,void
			 * 2,List<String> list
			 */
			public static void sort(List<String> list) {
				TreeSet<String> ts = new TreeSet<>(new Comparator<String>() {		//定义比较器(new Comparator(){}是Comparator的子类对象)
		
					@Override
					public int compare(String s1, String s2) {						//重写compare方法
						int num = s1.compareTo(s2);									//比较内容
						return num == 0 ? 1 : num;									//如果内容一样返回一个不为0的数字即可
					}
				});
				
				ts.addAll(list);													//将list集合中的所有元素添加到ts中
				list.clear();														//清空list
				list.addAll(ts);													//将ts中排序并保留重复的结果在添加到list中
			}

###17.17_集合框架(练习)
* 从键盘接收一个字符串, 程序对其中所有字符进行排序,例如键盘输入: helloitcast程序打印:acehillostt

		Scanner sc = new Scanner(System.in);			//创建键盘录入对象
		System.out.println("请输入一行字符串:");
		String line = sc.nextLine();					//将键盘录入的字符串存储在line中
		char[] arr = line.toCharArray();				//将字符串转换成字符数组
		TreeSet<Character> ts = new TreeSet<>(new Comparator<Character>() {

			@Override
			public int compare(Character c1, Character c2) {
				//int num = c1.compareTo(c2);
				int num = c1 - c2;					//自动拆箱
				return num == 0 ? 1 : num;
			}
		});
		
		for(char c : arr) {
			ts.add(c);
		}
		
		for(Character ch : ts) {
			System.out.print(ch);
		}
###17.18_集合框架(练习)
* 程序1： 程序启动后, 可以从键盘输入接收多个整数, 直到输入quit时结束输入. 把所有输入的整数倒序排列打印.

			Scanner sc = new Scanner(System.in);		//创建键盘录入对象
			System.out.println("请输入: ");
			TreeSet<Integer> ts = new TreeSet<>(new Comparator<Integer>() {//将比较器传给TreeSet的构造方法
	
				@Override
				public int compare(Integer i1, Integer i2) {
					//int num = i2 - i1;					//自动拆箱
					int num = i2.compareTo(i1);
					return num == 0 ? 1 : num;
				}
			});
			
			while(true) {
				String line = sc.nextLine();			//将键盘录入的字符串存储在line中
				if("quit".equals(line))					//如果字符串常量和变量比较,常量放前面,这样不会出现空指针异常,变量里面可能存储null
					break;
				try {
					int num = Integer.parseInt(line);		//将数字字符串转换成数字
					ts.add(num);
				} catch (Exception e) {
					System.out.println("您录入的数据有误,请输入一个整数");
				}
				
			}
			
			for (Integer i : ts) {						//遍历TreeSet集合
				System.out.println(i);
			}
###17.19_集合框架(键盘录入学生信息按照总分排序后输出在控制台)
* A:案例演示
	* 需求：键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台。

			Scanner sc = new Scanner(System.in);
			System.out.println("请输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩)");
			TreeSet<Student> ts = new TreeSet<>(new Comparator<Student>() {
				@Override
				public int compare(Student s1, Student s2) {
					int num = s2.getSum() - s1.getSum();			//根据学生的总成绩降序排列
					return num == 0 ? 1 : num;
				}
			});
			
			while(ts.size() < 5) {
				String line = sc.nextLine();
				try {
					String[] arr = line.split(",");
					int chinese = Integer.parseInt(arr[1]);				//转换语文成绩
					int math = Integer.parseInt(arr[2]);				//转换数学成绩
					int english = Integer.parseInt(arr[3]);				//转换英语成绩
					ts.add(new Student(arr[0], chinese, math, english));
				} catch (Exception e) {
					System.out.println("录入格式有误,输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩");
				}
				
			}
			
			System.out.println("排序后的学生成绩是:");
			for (Student s : ts) {
				System.out.println(s);
			}

###17.20_day17总结
* 1.List
	* a.普通for循环, 使用get()逐个获取
	* b.调用iterator()方法得到Iterator, 使用hasNext()和next()方法
	* c.增强for循环, 只要可以使用Iterator的类都可以用
	* d.Vector集合可以使用Enumeration的hasMoreElements()和nextElement()方法
* 2.Set
	* a.调用iterator()方法得到Iterator, 使用hasNext()和next()方法
	* b.增强for循环, 只要可以使用Iterator的类都可以用
* 3.普通for循环,迭代器,增强for循环是否可以在遍历的过程中删除 

* ******************************
###18.01_集合框架(Map集合概述和特点)
* A:Map接口概述
	* 查看API可以知道：
		* 将键映射到值的对象
		* 一个映射不能包含重复的键
		* 每个键最多只能映射到一个值
* B:Map接口和Collection接口的不同
	* Map是双列的,Collection是单列的
	* Map的键唯一,Collection的子体系Set是唯一的
	* Map集合的数据结构值针对键有效，跟值无关;Collection集合的数据结构是针对元素有效
	
###18.02_集合框架(Map集合的功能概述)
* A:Map集合的功能概述
	* a:添加功能
		* V put(K key,V value):添加元素。
			* 如果键是第一次存储，就直接存储元素，返回null
			* 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值
	* b:删除功能
		* void clear():移除所有的键值对元素
		* V remove(Object key)：根据键删除键值对元素，并把值返回
	* c:判断功能
		* boolean containsKey(Object key)：判断集合是否包含指定的键
		* boolean containsValue(Object value):判断集合是否包含指定的值
		* boolean isEmpty()：判断集合是否为空
	* d:获取功能
		* Set<Map.Entry<K,V>> entrySet():获取集合中所有的键值对
		* V get(Object key):根据键获取值
		* Set<K> keySet():获取集合中所有键的集合
		* Collection<V> values():获取集合中所有值的集合
	* e:长度功能
		* int size()：返回集合中的键值对的个数

###18.03_集合框架(Map集合的遍历之键找值)
* A:键找值思路：
	* 获取所有键的集合
	* 遍历键的集合，获取到每一个键
	* 根据键找值
* B:案例演示
	* Map集合的遍历之键找值

			HashMap<String, Integer> hm = new HashMap<>();
			hm.put("张三", 23);
			hm.put("李四", 24);
			hm.put("王五", 25);
			hm.put("赵六", 26);
			
			/*Set<String> keySet = hm.keySet();			//获取集合中所有的键
			Iterator<String> it = keySet.iterator();	//获取迭代器
			while(it.hasNext()) {						//判断单列集合中是否有元素
				String key = it.next();					//获取集合中的每一个元素,其实就是双列集合中的键
				Integer value = hm.get(key);			//根据键获取值
				System.out.println(key + "=" + value);	//打印键值对
			}*/
			
			for(String key : hm.keySet()) {				//增强for循环迭代双列集合第一种方式
				System.out.println(key + "=" + hm.get(key));
			}
	
###18.04_集合框架(Map集合的遍历之键值对对象找键和值)
* A:键值对对象找键和值思路：
	* 获取所有键值对对象的集合
	* 遍历键值对对象的集合，获取到每一个键值对对象
	* 根据键值对对象找键和值
* B:案例演示
	* Map集合的遍历之键值对对象找键和值
	
			HashMap<String, Integer> hm = new HashMap<>();
			hm.put("张三", 23);
			hm.put("李四", 24);
			hm.put("王五", 25);
			hm.put("赵六", 26);
			/*Set<Map.Entry<String, Integer>> entrySet = hm.entrySet();	//获取所有的键值对象的集合
			Iterator<Entry<String, Integer>> it = entrySet.iterator();//获取迭代器
			while(it.hasNext()) {
				Entry<String, Integer> en = it.next();				//获取键值对对象
				String key = en.getKey();								//根据键值对对象获取键
				Integer value = en.getValue();							//根据键值对对象获取值
				System.out.println(key + "=" + value);
			}*/
			
			for(Entry<String,Integer> en : hm.entrySet()) {
				System.out.println(en.getKey() + "=" + en.getValue());
			}
		
C:源码分析

注意: Map.Entry<K,V> 表示Map接口内部存在Entry接口。

###18.05_集合框架(HashMap集合键是Student值是String的案例)
* HashMap中的key如果是自定义类型，则需要重写hashCode与equals方法
* A:案例演示
	* HashMap集合键是Student值是String的案例

###18.06_集合框架(LinkedHashMap的概述和使用)
* 底层实现类似LinkedHashSet
* A:案例演示 LinkedHashMapTest.java
	* LinkedHashMap的特点
		* 底层是链表实现的可以保证怎么存就怎么取

###18.07_集合框架(TreeMap集合键是Student值是String的案例)
* A:案例演示 TreeMapTest.java
	* TreeMap集合键是Student值是String的案例

###18.08_集合框架(统计字符串中每个字符出现的次数)
* A:案例演示
	* 需求：统计字符串中每个字符出现的次数
			String str = "aaaabbbcccccccccc";
			char[] arr = str.toCharArray();						//将字符串转换成字符数组
			HashMap<Character, Integer> hm = new HashMap<>();	//创建双列集合存储键和值
			
			for(char c : arr) {									//遍历字符数组
				/*if(!hm.containsKey(c)) {						//如果不包含这个键
					hm.put(c, 1);								//就将键和值为1添加
				}else {											//如果包含这个键
					hm.put(c, hm.get(c) + 1);					//就将键和值再加1添加进来
				}
				
				//hm.put(c, !hm.containsKey(c) ? 1 : hm.get(c) + 1);
				Integer i = !hm.containsKey(c) ? hm.put(c, 1) : hm.put(c, hm.get(c) + 1);
						}
			
			for (Character key : hm.keySet()) {					//遍历双列集合
				System.out.println(key + "=" + hm.get(key));
			}

###18.09_集合框架(集合嵌套之HashMap嵌套HashMap)
* A:案例演示
	* 集合嵌套之HashMap嵌套HashMap
	* 一个专业可以包含多个班级
	* java1班 里面包含3个学生   	HashMap<String,Student> javaClass1;
	* java2班 也包含 3个学生		HashMap<String,Student> javaClass2;
	* 软件开发专业 包含java1 java2班	HashMap<"Java1班",javaClass1> RJKAMap;

###18.10_集合框架(HashMap和Hashtable的区别)
* A:面试题
	* HashMap和Hashtable的区别
		* Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高
		* Hashtable不可以存储null键和null值,HashMap可以存储null键和null值
* B:案例演示	
	* HashMap和Hashtable的区别

###18.11_集合框架(Collections工具类的概述和常见方法讲解)
* A:Collections类概述
	* 针对集合操作 的工具类 
* B:Collections成员方法
* 
		public static <T> void sort(List<T> list)
		public static <T> int binarySearch(List<?> list,T key)
		public static <T> T max(Collection<?> coll)
		public static void reverse(List<?> list)
		public static void shuffle(List<?> list)

###18.12_集合框架(模拟斗地主洗牌和发牌)
* A:案例演示
	* 使用ArrayList集合模拟斗地主洗牌和发牌，牌没有排序

			//买一副扑克
			String[] num = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"};
			String[] color = {"方片","梅花","红桃","黑桃"};
			ArrayList<String> poker = new ArrayList<>();
			
			for(String s1 : color) {
				for(String s2 : num) {
					poker.add(s1.concat(s2));
				}
			}
			
			poker.add("小王");
			poker.add("大王");
			//洗牌
			Collections.shuffle(poker);
			//发牌
			ArrayList<String> gaojin = new ArrayList<>();
			ArrayList<String> longwu = new ArrayList<>();
			ArrayList<String> me = new ArrayList<>();
			ArrayList<String> dipai = new ArrayList<>();
			
			for(int i = 0; i < poker.size(); i++) {
				if(i >= poker.size() - 3) {
					dipai.add(poker.get(i));
				}else if(i % 3 == 0) {
					gaojin.add(poker.get(i));
				}else if(i % 3 == 1) {
					longwu.add(poker.get(i));
				}else {
					me.add(poker.get(i));
				}
			}
			
			//看牌
			
			System.out.println(gaojin);
			System.out.println(longwu);
			System.out.println(me);
			System.out.println(dipai);

###18.13_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的原理图解)
* A:画图演示
	* 画图说明排序原理

###18.14_集合框架(模拟斗地主洗牌和发牌并对牌进行排序的代码实现)
* A:案例演示
	* 模拟斗地主洗牌和发牌并对牌进行排序的代码实现
* 
			//买一副牌
			String[] num = {"3","4","5","6","7","8","9","10","J","Q","K","A","2"};
			String[] color = {"方片","梅花","红桃","黑桃"};
			HashMap<Integer, String> hm = new HashMap<>();			//存储索引和扑克牌
			ArrayList<Integer> list = new ArrayList<>();			//存储索引
			int index = 0;											//索引的开始值
			for(String s1 : num) {
				for(String s2 : color) {
					hm.put(index, s2.concat(s1));					//将索引和扑克牌添加到HashMap中
					list.add(index);								//将索引添加到ArrayList集合中
					index++;
				}
			}
			hm.put(index, "小王");
			list.add(index);
			index++;
			hm.put(index, "大王");
			list.add(index);
			//洗牌
			Collections.shuffle(list);
			//发牌
			TreeSet<Integer> gaojin = new TreeSet<>();
			TreeSet<Integer> longwu = new TreeSet<>();
			TreeSet<Integer> me = new TreeSet<>();
			TreeSet<Integer> dipai = new TreeSet<>();
			
			for(int i = 0; i < list.size(); i++) {
				if(i >= list.size() - 3) {
					dipai.add(list.get(i)); 						//将list集合中的索引添加到TreeSet集合中会自动排序
				}else if(i % 3 == 0) {
					gaojin.add(list.get(i));
				}else if(i % 3 == 1) {
					longwu.add(list.get(i));
				}else {
					me.add(list.get(i));
				}
			}
			
			//看牌
			lookPoker("高进", gaojin, hm);
			lookPoker("龙五", longwu, hm);
			lookPoker("冯佳", me, hm);
			lookPoker("底牌", dipai, hm);
			
		}
		
		public static void lookPoker(String name,TreeSet<Integer> ts,HashMap<Integer, String> hm) {
			System.out.print(name + "的牌是:");
			for (Integer index : ts) {
				System.out.print(hm.get(index) + " ");
			}
			
			System.out.println();
		}
###18.15_集合框架(泛型固定下边界)
* ? super E 拿出来到比较器中做比较, TreeMap(Comparator<? super K> comparator);
* ? extends E 放进去，放入父类对象集合, boolean addAll(Collection<? extends E> c); 

###18.16_day18总结
* 把今天的知识点总结一遍。