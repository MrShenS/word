第五章：面向对象（OO，Object-Oriented）
目标：
	1.面向对象的特征：封装，继承，多态
	2.private和public修饰符
	3.对象的创建和初始化
	4.方法的调用
	5.构造器，方法的重写和重载
	6.this关键字
	7.Java中的package，import
	8.类和类之间的关系，方法和方法之间的关系

1.什么是面向对象？
	面向过程：
	面向对象：不是Java特有的，是一种思想；
		OOP：Object-Oriented Programming，面向对象编程
		OOA：Object-Oriented Analysis，面向对象分析
		OOD：Object-Oriented Design，面向对象设计

	类：  对具有相同特征，相同行为的事物的抽象描述。
	对象：某一类（具有相同属性和相同行为）事物中的具体个体。

	面向对象的三个特征：
		封装：
		继承：
		多态：
		类：
对象：
	万物皆对象；
	对象是唯一的；
	对象具有属性和行为；
	对象具有状态。

方法：是某个对象能够改变该对象状态的行为；
方法的定义：
	[权限修饰符] [static] 返回值类型 方法名(形参1[,形参N]){
		方法体;
		[return 值;]
	}

	权限修饰符：
		public：公共的，使用该修饰符修饰的方法，在任意一个类中都可以调用。
		private：私有的，只能在该方法所属的类中进行调用。

	[static]：表示static修饰的方法直属于类， 
	返回值类型：方法的调用者在调用该方法执行结束之后，是否需要获取该方法所处理的结果数据（返回值）。
		有返回值：视具体情况而定；基本类型和引用类型。
		无返回值：void

	方法名：需要遵循标识符的命名规则和规范。
		规则：
			不能以数字开头；
			不能包含特殊字符；
			只能以字母，_，$开头；
			中间可以包含数字。
		规范：
			见名知义；
			驼峰命名法。
		
	参数：
		形式参数：在定义方法的时候，给该方法所指定的参数称之为形参；
			int add(int a,int b){
				return a+b;
			}
		实际参数：在调用方法的时候，给该方法所传递的参数称之为实参；
			int num=add(1,3);
			add(4,5);

	方法体：该方法的具体执行过程。

	返回值：方法执行的结果数据；当该方法执行完成之后，需要返回数据给调用者，则需要使用return语句将数据返回。
		注意：
			1.return语句会结束方法的执行；
			2.return语句后面不能再有代码；
			3.返回值类型为void的方法也可以有return语句；
			4.只要方法的返回值类型不是void，则该方法必须要有return语句。

Java中方法的具体定义：
	public int add(int a,int b){
		int sum=a+b;
		return sum;
	}

	public void printArray(int[] arr){
		if(arr.length>5){
			return;
			// syso();
		}
		syso(Arrays.toString(arr));
	}

构造方法（构造器）：
	作用：
		1.配合new关键字在堆内存中创建对象；
		2.对创建的对象的属性(成员变量)进行初始化；
		3.执行一些其他的初始化代码。
	定义：
		方法名是类名；
		没有返回值类型；
		不需要rerun语句；

	具体定义：
		权限修饰符 类名(参数1[,参数N]){
			方法体;
		}

	注意：
		1.如果在类中没有定义构造器，则该类有一个默认的无参构造器；
		2.如果在该类中定义了构造器，则不会再有默认的无参构造器；如果需要使用无参构造器创建对象，需要在类中显式地定义无参构造器。

	例如：
		class Student{
			int age;

			public Student(){
				this.age=10;
			}

			public Student(int age){
				this.age=age;
			}
		}

构造代码块：
	定义：在类中只以“{}”所包围的代码，称之为构造代码块；
	作用：
		1.成员变量初始化成固定的值；
		2.执行其他初始化代码。
	注意：
		1.该代码块是伴随着构造器的执行而执行的。
		2.优先于构造器执行。
	
	class Student{
		int age;

		{
			代码
		}

		Student(int age){
			this.age=age;
		}
	}

this关键字：
	1.指代本类对象；
	2.指代本类中的构造器,在本类的构造器中进行本类其他构造器的调用；
	3.当使用this调用本类中的构造器的时候，该this语句只能放在第一句代码位置。
	4.在类的构造器中，最多只能出现一次this语句来调用本类中的其他构造器。

	class Student{
		int age;
		String name;

		Student(int age){
			this.age=age;
		}

		Student(String name){
			this.name=name;
		}

		Student(int age,String name){
			this(name);
			this(age);
		}
	}

匿名对象：
	1.没有对象名的对象；
	2.当用new创建的对象只使用一次的时候；
	3.当将对象作为实参进行参数传递的时候；

	class Person{
		int age;

		Person(int age){
			this.age=age;
		}
		
		void say(){
			System.out.println(this.age);
		}

		void eat(){
			syso("吃");
		}
	}

	class TestPerson{
		main(){
			Person psn=new Person(10);
			psn.say();
			psn.eat();

			new Person(10).say();
			new Person(20).eat();
		}
	}

	class School{
		int age;

		void edu(Student stu){
			stu.age+=4;
		}
	}

	Student stu=new Student();
	edu(stu);

	edu(new Student());

Java中面向对象的三个特征：
封装（Encapsulation）：
	1.将实现的细节隐藏起来以保证安全性和健壮性；
	2.暴露公共接口给用户使用；

	class Person{
		private int age;  // 隐藏了该变量的访问

		void say(){
			syso(this.age);
		}

		// 对外暴露的使用接口
		public void setAge(int age){
			if(age<0||age>130){
				syso("不合法的age值！");
			}else{
				this.age=age;
			}		
		}

		public int getAge(){
			return this.age;
		}
	}

	class TestPsn{
		main(){
			Psn psn=new Psn();
			// psn.age=-20;   // 编译出错
			psn.setAge(-20);
			psn.say();
		}
	}


	int add(int a,int b){
		int x=a+b;
		x=x*100/100;
		return x;
	}

方法重载(Overloading)：
	在同一个类中，定义多个方法名相同但是方法的形参不同的现象称之为方法重载。

	形参不同：
		1.参数个数不同：
		2.参数的数据类型不同：
		3.参数的顺序不同：

	注意：重载只和参数相关，和返回值类型，权限修饰符无关。

	构造器重载：

		class Student{
			int age;
			String name;

			Student(int age){
				this.age=age;
			}

			Student(String name){
				this.name=name;
			}

			Student(String name,int age){
				this.name=name;
				this.age=age;
			}

			Student(int age,String name){
				this.age=age;
				this.name=name;
			}
		}

		new Student(20,"Kevin");

		---------------------------------------

		class Student{
			void add(int a,int b){
			
			}

			int add(int a,int b){
			
			}

			mian(){
				Student stu=new Student();
				stu.add(1,2);
			}
		}

参数传递：
	Java中的参数是以什么形式传递的？值传递

	Java中的参数传递只有值传递，没有引用传递。

	值传递：当传递给方法的参数是八种基本数据类型和String类型的时候，该参数的传递是值传递，在参数传递的过程中，
	                将传递的实参所代表的值拷贝一份传递给形参，让形参来收。基本数据类型作为参数传递之后，不会改变原来的变量中存储的值。

	class Demo{
		static void show(int x){
			x=10;
			syso(x);
		}

		mian(){
			int num=100;
			show(num);
			syso(num);
		}
	}

	String ste="Hello";
	String str=new String("123");

	引用传递：当传递给方法的参数是引用类型的数据的时候，此时是将该引用的地址(值)传递给了形参。
	                    当传递的是引用值的时候，改变了引用的对象的状态，原来的对象的状态也随之改变。
	引用：栈内存中的变量指向堆内存中对象的过程。
	


	class School{
		void edu(Student stu){
			stu.age+=4;
		}
	}

	class Student{
		int age;
	}

	class Demo{
		main(){
			School scl=new School();
			Student stu=new Student();
			stu.age=16;
			scl.edu(stu);
			syso(stu.age);
		}
	}

继承：
	子类：
	父类：
	Object类：所有的类的父类，超类。该类是所有类的父类，该类被其他所有的类隐式继承。
	Java中的继承是单一继承，没有多继承，但是有多实现。
	Java中的继承是一种“is a”关系，使用关键字extends表现继承关系。
	Java中，创建一个类时，总是存在继承关系，Java中所有的类都默认继承自Object类。

	class Person extends Animal{
		String name;
	}

	class Student extends Person{
		void study(){
		}
	}

	class Teacher extends Person{
		void teach(){
		}
	}

	class Animal extends Object{
		int age;
		void eat(){}
	}

	class Dog{
		
	}

	class Cat{
	
	}

	继承的特点：
	1.子父类中的成员变量：
		1.如果子父类中存在相同名字的成员变量，则使用子类对象调用该变量时，子类中的变量会将父类中的变量隐藏；
		    如果使用父类对象调用该变量时，调用的是父类中的变量。
		2.子类不能直接访问父类中的私有（被private修饰的）成员变量和成员方法。
		3.如果父类中提供了某个私有成员的公共访问方式，子类可以通过该公共的访问方式来访问父类中的成员。
		4.super关键字：
			1.当子类中具有和父类同名的成员时，super可以在子类中访问父类中的成员；
			    当子类中没有和父类中同名的成员，子类访问父类的成员可以使用super或者this。
			2.在子类的构造器中访问父类的构造器。
			3.super和this一样，也只能放在构造器中代码的第一行。
			4.super和this只能在构造器 或者成员方法中使用；而不能在静态方法或者静态代码块中使用。
			5.在子类的构造器中，如果没有this，会使用super隐式调用父类中的【无参构造器】；
			    因为子类继承自父类，子类必须知道父类中的成员。如果在父类中显式的定义了有参构造器，
			    则在子类中需要显式的调用父类的有参构造器。

			练习：super和this能不能同时出现？
			视情况而定，当super和this调用成员时，可以同时出现。
			当调用构造器时，不能同时出现，因为在调用构造器时，这两关键字必须都放在构造器代码第一行。

			练习2：下面代码的执行结果是什么？
				class Fu{
					Fu(){
						syso("父类无参构造器！");
					}
				}
				class Zi extends Fu{
					Zi(){
						syso("子类无参构造器！");
					}
				}

				class Demo{
					main(){
						Zi z=new Zi();
					}
				}

		--------------------------------------------------
		class Person{
			int age;
			String name;

			void eat(){
				syso("人吃饭！");
			}
		}

		class Student extends Person{
			void study(){
				syso("学生学习！");
			}
		}

		class Demo{
			main(){
				Student stu=new Student();
				stu.age=10;
				stu.name="Kevin";
				syso(stu.age+"::"+stu.name);
			}
		}

		--------------------------------------------------------

		class A{
			A(){
			
			}

			A(int num){
			
			}
		}

		class B extends A{
			B(){
				this("123");
				
				// super();
			}

			B(String x){
				this();

			}
		}

	2.子父类中的成员方法：
		1.在子类中调用成员方法时，如果某方法在父类中有，子类中没有，则调用父类中的方法；
		   如果某方法在子父类中都有，则调用子类中的方法。此种现象称之为方法的重写（覆盖），overriding。
		2.如果父类中的方法被私有化，则子类无法调用该方法。

		方法的重写：
			1.在子类中具备和父类中方法名相同并且参数列表相同的方法，称之为子类中的方法重写了父类中的方法。
			2.子类不能重写父类中的私有化成员方法，因为父类中的私有化成员方法在子类中看不到。
			3.重写之后的方法的权限要比父类大。
			4.重写之后的子类方法的抛出的异常要比父类方法抛出的异常小。
			5.静态方法不能被重写。

		

		class Fu{
			void show(){}
		}

		class Zi extends Fu{
			void show(){}
		}

	3.子父类中的构造器：参见1中的super和this。

重载和重写区别：
	1.重载发生在同一个类中。同类同方法名参数列表不同。
	2.重写发生在子父类中。方法名相同参数列表相同。重写对权限修饰符和抛出的异常的范围有规定：
		1.子类中重写的父类的方法权限要比父类中的大。
		2.异常要比父类中的异常小。

Java中面向对象的特点――多态
	1.同一个对象具有多种形态。
	2.一个对象只有一种类型。
	3.一个变量可以有多种类型。
	4.多态表现在运行时，而重载表现在编译时。

	多态的前提：
		1.必须要有继承。

	class Person{
		int age;
		String name;

		void eat(){
		
		}
	}

	class Student extends Person{
		void study(){
			
		}
	}

	class Demo{
		main(){
			Student stu=new Student();

			Person psn=new Person();

			// 父类引用指向子类对象
			Person p=new Student();
		}
	}

	多态中的成员变量：编译看左边，运行看左边。
		class Fu{
			// int age=100;
		}

		class Zi extends Fu{
			int age=200;
		}

		class Demo{
			main(){
				Zi z=new Zi();
				Fu f=new Fu();
				Fu fz=new Zi();
				syso(z.age+":"+":"+fz.age);
			}
		}

	多态中的成员方法：编译看左边，运行看右边。

体现多态的三要素：
	1.必须要有继承；
	2.必须要有重写；
	3.父类引用指向子类对象。

	引用：
		Student stu=new Student();

	class Animal{
		int age=100;
	
		void eat(){
			syso("动物食物！！！");
		}
	}

	class Cat extends Animal{
		void eat(){
			syso("猫吃鱼！！！");
	      	}
	}

	class TestDuotai{
		main(){
			Animal anm=new Cat();
		}
	}

成员的角度理解多态：
	成员变量：编译看左边，运行看左边。（优先使用父类）
		1.同名成员变量在子类和父类中都有：编译通过，运行时正常访问父类中的成员。
		2.同名成员变量在父类中有，子类中没有：编译通过，运行时正常访问父类中的成员。
！！！！3.同名成员变量在父类中没有，子类中有：编译报错，找不到符号；
		4.同名成员变量在子父类中都没有：跟3一样。
                
	成员方法：编译看左边，运行看右边。（优先使用子类）
		1.同名成员方法在子父类中都有：编译通过，程序运行时调用子类中的成员方法；
		2.同名成员方法父有子没有：编译通过，程序运行时调用父类中的成员方法；
！！！！3.同名成员方法父没有子有：编译报错，找不到符号。
		4.同名成员方法子父类中都没有：同3一样。

	注意：静态方法有所区别，编译看左边，运行看左边。

多态的应用：
	封装：
		1.数据隐藏：
			private int age;
			get
			set

		2.代码抽取：
			nums[x]^=nums[z];
			nums[z]^=nums[x];
			nums[x]^=nums[z];

			swap(nums[x],nums[z]);

			void swap(int x,int z){
				x^=z;
				z^=x;
				x^=z;
			}

	1.多态的应用：
		将多个具有共性的类所执行的共性代码进行抽取，封装成方法，在该方法中只需要传递这多个类的父类引用即可。
	
	2.引用类型转换：
		1.基本数据类型：
			整数转整数：
				大转小：强制转换，显式转换
				小转大：自动转换，隐式转换

			小数转小数：
				大转小：强制转换，显式转换
				小转大：自动转换，隐式转换

			小数转整数：强制转换，因为会丢失精度。

			整数转小数：自动转换。
		2.引用类型：
			1.强制转换：大转小，显式转化，向下转型。
			2.自动转换：小转大，隐式转化，向上转型。

		3.向上转型：
			Animal anm=new Cat();
			父类引用指向子类对象，此时JVM会默认地将对象new Cat()从Cat类型向上转型至Animal类型。

		4.向下转型：
			父类引用指向子类对象，但现在需要将父类引用转变成子类因公，所以就需要向下转型，
			但是在转型之前先进行判断，
			如果该对象的类型和即将要向下转型的类型一致，才能进行向下转型，或者叫强制类型转换。

			instanceof关键字：
				boolean b=对象(引用) instanceof 类;

			该关键字用于判断左边的对象(引用)的类型是够是右边类类型。
			class Animal{
				void eat(){}
			}

			class Dog extends Animal{
				void eat(){}    // 共性方法 
				void lookHouse(){  // 特有方法
					syso("看家！");
				}
			}

			class Cat extends Animal{
				void eat(){}
				void catchMouse(){
					syso("抓耗子！");
				}
			}

			void func(Animal anm){
				if(anm instanceof Dog){
					Dog d=(Dog)anm;
					d.lookHouse();
				}else if(anm instanceof Cat){
					((Cat)anm).catchMouse();
				}
			}

			如果不使用instanceof进行类型判断，很有可能造成类转换异常。
			Animal anm=new Cat();
			Dog d=(Dog)anm;
			异常：ClassCastException
多态的好处：
	1.减少代码量；
	2.具有某种关系的多个类中的共性代码进行抽取，然后封装成方法，然后在传递参数的时候以这些类的父类型进行参数传递。

   尽量使用数据耦合 少使用控制耦合 限制公共耦合范围   尽量避免使用内容耦合

    数据耦合：模块间通过参数传递基本数据类型
    控制耦合：一个模块通过控制在界面上传递一个信号进行控制另一个模块
    公共耦合：两个或两个模块之间使用同一个全局静态量
    内容耦合：当一个模块直接操作另一个模块或者直接转入另一个模块时 就发生了内容耦合 
                          被修改的模块直接依赖修改他的模块