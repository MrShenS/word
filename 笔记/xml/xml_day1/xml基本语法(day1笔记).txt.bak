
授课内容
	XML语法
	XML约束
	XML解析   
	
一 XML基本概述
1. XML简单的历史介绍	
	1969年 GML   通用标记语言
		用于计算机之间的通信,通信就会传输数据,那么就需要一种数据的规范
	1985年 SGML  标准通用标记语言
		对GML进行完善
	1993年 HTML  超文本的标记语言(HyperText Markup Language)
		随着万维网的推广,在SGML的基础上,又出现了HTML语言,用于万维网上的页面展示
		但HTML有不少缺陷: 
			a.标签不能扩展，不能自定义,只能使用默认的
			b.兼容性不好(不同浏览器同一页面效果可能不一样)
			c.不能描述数据(主要做页面展示)
			
		例如描述一个学生信息  name:张三 id：12 age：23
			<table>表格
				<tr>行
					<td>张三</td>
					<td>12</td>
					<td>23</td>
				</tr>'
			</table>
	1998年 XML 可扩展的标记语言(Extensible Markup Language)
		W3C组织在1998年推出了可扩展标记语言XML(W3C万维网联盟创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构)。
		XML语言的本身是用来替代HTML语言的,但是俩种语言还有一定差异的,所以中间出现了一种过渡的语言:XHTML。但实际上XML语言已经很难替代HTML语言了,因为HTML语言的使用在整个万维网上使用太广泛了。

		XML中标签可以自定义，描述性很好，例如：
			<student id="001">
				<name>lucy</name>
				<age>24</age>
			</student>

2. XML显著优点
	可扩展标记
	可描述数据
	
	传输数据案例：
		项目小组
		组长：张三
		组员：。。。
		测试：李四
		监督人员：。。。
		<项目小组 项目名称="Xxx系统">
			<组长>张三</组长>
			<组员们>
				<组员>...</组员>
				<组员>...</组员>
				<组员>...</组员>
			</组员们>
			<测试人员们>
				<测试人员>...</测试人员>
				<测试人员>...</测试人员>
				<测试人员>...</测试人员>
			</测试人员们>
			<监督人员>李四</监督人员>
		</项目小组>
	
	
3. XML有什么作用,为什么要学习XML
	第一个用处: 做数据传输，具备一定的格式
		a.数据的可读性
		b.将来的扩展
		c.将来的维护
		XML现在已经是业内传输数据的标准,它和开发语言无关。

	第二个用处:配置文件,之前使用的.properties资源文件中描述的信息不丰富，无法描述层次复杂的数据
	
	
	第三个用处: 保存数据,充当小型的数据库
		保存数据一般是使用数据库保存,或者使用一般的文件保存,这个时候也可以选择XML文件,因为XML可以描述复杂的数据关系。从普通文件中读取数据的速度肯定是比从数据库中读取数据的速度快,只不过这样不是很安全而已

二 XML基本语法
1.文档声明
	XML文件的后缀为.xml；
	XML文本要求文件有一个头部声明(用来告诉解析器一些相关信息)；
		<?xml version="1.0" encoding="UTF-8"?>
		头部声明是给解析器看的，表明当前文件是xml文件,XML版本为1.0,文件内容使用的字符编码为UTF-8。
		
	注意:要小心在系统中这个xml文件保存时候的编码,是否和文件内容中设置的编码一致；
	
	头部声明可以省略，如果不写，会默认加上<?xml version="1.0"?>。
	
	注意：
		XML语法很严格，只要有问题，浏览器就无法正常显示；
		如果文件的保存格式不对，无法显示；
		如果文件格式上有任何问题，也无法显示。
		
	ansi (American National Standards Institute)美国国家标准协会
	ansi编码 是这个协会组织指定的一种字符编码
	ansi编码在不同国家表示是不用的 中文操作系统中的ansi编码是GB2312 GBK
	
2.元素
	2.1根元素
		每个XML文档必须有且只有一个根元素；
		根元素是一个完全包括文档中其他所有元素的元素；
		根元素的起始标记要放在所有其他元素的起始标记之前;
		根元素的结束标记要放在所有其他元素的结束标记之后。
	
	2.2标签
		xml文件中的标记也可以叫标签、元素、节点。
		XML元素指XML文件中出现的标签，一个标签分为开始标签和结束标签，一个标签有如下几种书写形式；
		例如：
			包含标签体：<a>www.baidu.com</a>
			不含标签体的：<a></a>, 可以简写为：<a/>
			一个标签中也可以嵌套若干子标签，但所有标签必须合理的嵌套，
				例如：<a>你好!<b>程序员</b></a>；
			但绝对不允许交叉嵌套。
				例如：<a>你好!<b>程序员</a></b> 
	
	2.3 标签内容
		对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。
		例如：下面两段内容的意义是不一样的(解析阶段才关心)。
			<name>tom</name>
			<name>
				tom
			</name>
		由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，要特别注意。但是在一些封装好的解析方式中,是可以忽略掉这些空格和换行的。(例如在一些第三方提供的jar包中)
	
	2.4 元素命名规则
		一个XML元素可以包含字母、数字以及其它一些可见字符，但必须遵守下面的一些规范：
			a. 区分大小写，例如，<P>和<p>是两个不同的标记。
			b. 不能以数字开头.
			c. 不能包含空格。
		注意，XML语法十分严格，以上提到的点，任何一点出问题都不能在浏览器中正常显示。

3.属性 
	属性出现在 起始标签内部，和标签名用空格隔开。
	它的基本格式为：
		<元素名 属性名1="属性值" 属性名2="属性值" ...>
	
	注意: 
		a. 一个元素可以有多个属性;
		b. 属性值用双引号（"）或单引号（'）括起来;
		c. 特定的属性名称在同一个元素标记中只能出现一次;
		b. 属性值不能包括<, >, &等特殊字符。
		
	例如：
		<student id="100">
			<name>TOM</name>
		</student>

4.实体 ENTITY
	xml文件中有些特殊的字符是不能直接表示出来的,例如:大于号,小于号,单引号、双引号等等，为了表示它们，我们可以借助实体完成。
	实体可以分为两类：预定义实体、自定义实体。
	
	a.预定义字符实体,由XML规范预先定义好了
		&lt;		<
		&gt;		>
		&amp;		&
		&quot;		"
		&apos;		'
	
		注意：使用实体的格式是 &实体名字;
	
	b.自定义实体 ENTITY
	定义格式：
		<!DOCTYPE 根元素名称[ 	//其他字符串也可以，并不必须是根元素名称
			<!ENTITY 实体名1 "实体内容">
			<!ENTITY 实体名2 "实体内容">
			...
		]>

	eg:
		<!DOCTYPE courses[
			<!ENTITY company "昆山杰普软件科技有限公司">
		]>
		
	其中：company为实体名称；
		  "昆山杰普软件科技有限公司"是实体内容；
		  
		实体的使用  &company;
		
4.注释
	<!-- 这是一个注释 -->
	注意：
		a. 注释内容中不要出现--；
		b. 不要把注释放在标记内部；
			<Name <!-- the name -->>TOM</Name> 是不合适的
		c. 注释不能嵌套；
		d. 可以在除标记以外的任何地方放注释；

5.PCDATA,CDATA
	在XML文件内部，有两部分数据组成：可以解析的，不能解析的
		可以解析的 PCDATA
		不需要|不可以解析的  CDATA
		
	PCDATA (Parsed Character Data) 会被xml文档解析器解析的，但是有些特殊字符需要借助实体才可以被解析器解析，XML文件中的正常内容基本都是PCDATA。

	CDATA (Character Data) 不会被xml文档解析器解析的，按字符串原样输出。
	有些内容，例如< > &不想让解析,按照内容原样输出就可以了,这种情况可以使用CDATA。
	格式：
		<![CDATA[需要原样输出的字符串]]>
		
	例如： 	<![CDATA[<<<<]]>	  
			<test><![CDATA[&&&]]></test>
		  
		使用这个东西，我们可以保存二进制文件(图片)。
		后期myBatic里面用xml存放sql语句，里面包含很多特殊字符，也要用到CDATA。

6.处理指令
	处理指令，简称PI （processing instruction），用来指挥解析引擎解析XML文档内容。
	例如，在XML文档中可以使用css文件来指挥解析器解析xml文件，需要用到的指令为:xml-stylesheet
		<?xml-stylesheet type="text/css" href="css文件路径"?>

	注意：	
		处理指令必须以 <? 作为开头，以 ?> 作为结尾，XML文件的头部声明语句就是最常见的一种处理指令；
		XML文件中可以有多个处理指令。
		
	例如: class.xml文件:
		<?xml version="1.0" encoding="UTF-8"?>
		<?xml-stylesheet href="class.css" type="text/css"?>
		<class>
			<student id="001">
					<name>张三</name>
					<age>20</age>
			</student>
			<student id="002">
					<name>李四</name>
					<age>20</age>
			</student>
		</class>

	class.css文件:
		name{
			font-size:30px;
			font-weight:bold;
			color:red;
		}
		
		age{
			font-size:30px;
			font-weight:bold;
			color:green;
		}

四 XML命名空间 namespace
	在实际项目中，不同人员可能会在两个不同文档中使用相同的元素名，单独编码测试没有问题，但是项目整合时，就会出现命名冲突问题，命名空间可以很好的解决这个问题。
	
1.XML 命名空间提供避免元素命名冲突的方法
	在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。

	例如，下面 XML 文档携带着某个表格中的信息：
		<table>
		   <tr>
			   <td>Apples</td>
			   <td>Bananas</td>
		   </tr>
		</table>
		
	另一个XML 文档携带有关桌子的信息（一件家具）：
		<table>
		   <name>茶几</name>
		   <width>80</width>
		   <length>120</length>
		</table>
		
	假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 <table> 元素，就会发生命名冲突。XML 解析器无法确定如何处理这类冲突。
	
2.命名冲突解决方案
第一种解决方案:
	使用前缀来避免命名冲突。
	
	例如：
		<h:table>
		   <h:tr>
			   <h:td>Apples</h:td>
			   <h:td>Bananas</h:td>
		   </h:tr>
		</h:table>
		
	此 XML 文档携带着有关一件家具的信息：
		<f:table>
		   <f:name>茶几</f:name>
		   <f:width>80</f:width>
		   <f:length>120</f:length>
		</f:table>

	现在，命名冲突不存在了，这是由于两个文档都使用了不同的名称来命名它们的 <table> 元素 (<h:table> 和 <f:table>)。
	通过使用前缀，我们创建了两种不同类型的 <table> 元素。
	
	但解析器在解析过程中，会出现新的问题：前缀未绑定命名空间！

第二种解决方案:
	使用命名空间（Namespaces）。
	这个 XML 文档携带着某个表格中的信息：
		<h:table xmlns:h="http://www.briup.com/h">
		   <h:tr>
		   <h:td>Apples</h:td>
		   <h:td>Bananas</h:td>
		   </h:tr>
		</h:table>
		
	此 XML 文档携带着有关一件家具的信息：
		<f:table xmlns:f="http://www.briup.com/f">
		   <f:name>茶几</f:name>
		   <f:width>80</f:width>
		   <f:length>120</f:length>
		</f:table>
		
	与仅仅使用前缀不同，我们为 <table> 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。
	
注意：
	XML Namespace (xmlns) 命名空间属性，被放置于元素的开始标签之中(一般都会在根元素中声明)，并使用以下的语法：xmlns:namespace-prefix="namespaceURI"。
	当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。
	
	另外:
		用于标示命名空间的地址不会被解析器用于查找信息；
		xmlns具体赋什么值无关紧要，只要保证唯一即可。


第三种方案:
	默认的命名空间(Default Namespaces)。
	
	使用以下的语法:
		<根元素 xmlns="namespaceURI">
	
	为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作。
	
	这个 XML 文档携带着某个表格中的信息：
		<table xmlns="http://www.briup.com/h">   "http://www.briup.com/h":table
		   <tr>
		   <td>Apples</td>
		   <td>Bananas</td>
		   </tr>
		</table>
		
	此 XML 文档携带着有关一件家具的信息：
		<table xmlns="http://www.baidu.com/f">
		   <name>茶几</name>
		   <width>80</width>
		   <length>120</length>
		</table>

五  XML约束
	在XML技术里，可以编写一个文档来约束一个XML文档的书写规范，这称之为XML约束。
	
	需要XML约束的原因
	xml由于是可扩展的标记语言,所以在xml文件中的编写太过于自由,这样在很多种情况下并不合适。
	
	常用的约束技术
	XML DTD 
		DTD文件的后缀名为 .dtd
		DTD文件有自己独立的语法规范
	XML Schema
		Schema文件的后缀名为 .xsd
		Schema文件符合xml语法规范

六  DTD Document Type Define
	DTD的定义：描述元素、属性和其他杂项在xml文档中
	           的使用规则的说明
	DTD的分类：
		1).外部的DTD：DTD和xml文档不在同一个文件中
		2).内部的DTD：DTD和xml文档在同一个文件中
		3).混合的DTD：既有外部DTD，又有内部DTD
		
	DTD的目的：
		良构： 符合xml语法，没有问题
		有效:  符合约束条件的 良构xml文件
		验证该xml文档是否是有效的xml文档
		如果一个良构的xml文档满足了DTD的声明就是一个有效的xml文档。
		注意：良构 不一定  有效，但是有效一定良构

	DTD在元素中的声明：
		格式：<!ELEMENT  元素名 (内容模式)>
		内容模式：
			1).(#PCDATA)：元素内容为字符或者为空(不可以出现子标签)
			2).EMPTY：元素内容为空
			3).ANY：元素内容为任意的，主要是使用在元素内容不确定的情况下
			4).(Child Elements)： ，   |   +  *  ？
			5).混合元素
				eg：<!ELEMENT root (#PCDATA|name|age)*>
				<root>
					<name></name>
					<age></age>
				</root>
				子元素可以是name，也可以是age，顺序没有关系，频率也没有关系
		注意：浏览器是非验证的解析器，不会验证xml的有效性
		      validate===>验证xml文档
	
	属性的DTD声明：
		格式：<!ATTLIST 元素名  属性名  属性类型 属性默认值 
						      .........
						     属性名  属性类型 属性默认值
			   >
		属性类型：
			1).ID：属性值必须唯一,属性值必须满足命名规则
			2).enumerated：(枚举值1|枚举值2|枚举值3...),属性值必须在枚举值中
			3).CDATA：属性值为字符
		属性默认值：
			1).#REQUIRED：属性必须出现在元素的开始标签中。
			2).#IMPLIED：属性可以不出现，并且当它不出现的时候没有默认值 implied
			3).attribute-value：属性可以不出现，并且当它不出现的时候是有默认值的，而该属性
			           的默认值就是atttibute-value
			4).#FIXED：属性可以不出现，但是如果出现的话必须是指定的属性值，不出现的话也是
				指定的默认值

